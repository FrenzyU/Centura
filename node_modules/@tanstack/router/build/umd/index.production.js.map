{"version":3,"file":"index.production.js","sources":["../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../src/history.ts","../../src/utils.ts","../../src/path.ts","../../src/qss.ts","../../src/route.ts","../../src/routeConfig.ts","../../../store/build/esm/index.js","../../src/routeMatch.ts","../../src/searchParams.ts","../../src/router.ts"],"sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nimport { match } from 'assert'\n\nexport interface RouterHistory {\n  location: RouterLocation\n  listen: (cb: () => void) => () => void\n  push: (path: string, state: any) => void\n  replace: (path: string, state: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface RouterLocation extends ParsedPath {\n  state: any\n}\n\nconst popStateEvent = 'popstate'\n\nfunction createHistory(opts: {\n  getLocation: () => RouterLocation\n  listener: (onUpdate: () => void) => () => void\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n}): RouterHistory {\n  let currentLocation = opts.getLocation()\n  let unsub = () => {}\n  let listeners = new Set<() => void>()\n\n  const onUpdate = () => {\n    currentLocation = opts.getLocation()\n\n    listeners.forEach((listener) => listener())\n  }\n\n  return {\n    get location() {\n      return currentLocation\n    },\n    listen: (cb: () => void) => {\n      if (listeners.size === 0) {\n        unsub = opts.listener(onUpdate)\n      }\n      listeners.add(cb)\n\n      return () => {\n        listeners.delete(cb)\n        if (listeners.size === 0) {\n          unsub()\n        }\n      }\n    },\n    push: (path: string, state: any) => {\n      opts.pushState(path, state)\n      onUpdate()\n    },\n    replace: (path: string, state: any) => {\n      opts.replaceState(path, state)\n      onUpdate()\n    },\n    go: (index) => {\n      opts.go(index)\n      onUpdate()\n    },\n    back: () => {\n      opts.back()\n      onUpdate()\n    },\n    forward: () => {\n      opts.forward()\n      onUpdate()\n    },\n  }\n}\n\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.hash}${window.location.search}`)\n  const createHref = opts?.createHref ?? ((path) => path)\n  const getLocation = () => parseLocation(getHref(), history.state)\n\n  return createHistory({\n    getLocation,\n    listener: (onUpdate) => {\n      window.addEventListener(popStateEvent, onUpdate)\n      return () => {\n        window.removeEventListener(popStateEvent, onUpdate)\n      }\n    },\n    pushState: (path, state) => {\n      window.history.pushState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    replaceState: (path, state) => {\n      window.history.replaceState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n  })\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {}\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    listener: () => {\n      return () => {}\n    },\n    pushState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n  })\n}\n\nfunction parseLocation(href: string, state: any): RouterLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex, searchIndex) : '',\n    search: searchIndex > -1 ? href.substring(searchIndex) : '',\n    state,\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n","export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = Expand<{\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}>\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nexport function warning(cond: any, message: string): cond is true {\n  if (cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n\n  return true\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n","import invariant from 'tiny-invariant'\nimport { AnyPathParams } from './routeConfig'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part.startsWith('*')) {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.value === '*' && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(currentLocation.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  if (!from.startsWith(basepath)) {\n    return undefined\n  }\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  const baseSegments = parsePathname(from)\n  const to = `${matchLocation.to ?? '*'}`\n  const routeSegments = parsePathname(to)\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  if (str.charAt(0) === '0') return str\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import { RouteConfig, RouteOptions } from './routeConfig'\nimport {\n  AnyAllRouteInfo,\n  AnyRouteInfo,\n  DefaultAllRouteInfo,\n  RouteInfo,\n} from './routeInfo'\nimport { Router } from './router'\n\nexport interface AnyRoute extends Route<any, any, any> {}\n\nexport class Route<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n  TRouterContext = unknown,\n> {\n  routeInfo!: TRouteInfo\n  id!: TRouteInfo['id']\n  customId!: TRouteInfo['customId']\n  path!: TRouteInfo['path']\n  fullPath!: TRouteInfo['fullPath']\n  getParentRoute!: () => undefined | AnyRoute\n  childRoutes?: AnyRoute[]\n  options!: RouteOptions\n  originalIndex!: number\n  getRouter!: () => Router<\n    TAllRouteInfo['routeConfig'],\n    TAllRouteInfo,\n    TRouterContext\n  >\n  constructor(\n    routeConfig: RouteConfig,\n    options: TRouteInfo['options'],\n    originalIndex: number,\n    parent: undefined | Route<TAllRouteInfo, any>,\n    router: Router<TAllRouteInfo['routeConfig'], TAllRouteInfo, TRouterContext>,\n  ) {\n    Object.assign(this, {\n      ...routeConfig,\n      originalIndex,\n      options,\n      getRouter: () => router,\n      childRoutes: undefined!,\n      getParentRoute: () => parent,\n    })\n\n    router.options.createRoute?.({ router, route: this })\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { GetFrameworkGeneric } from './frameworks'\nimport { ParsePathParams } from './link'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { RouteInfo } from './routeInfo'\nimport { RouteMatch } from './routeMatch'\nimport { AnyRouter, RegisteredRouter, Router } from './router'\nimport { Expand, IsAny, NoInfer, PickUnsafe } from './utils'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\n\nexport type AnyLoaderData = {}\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport interface RouteMeta {}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> = (\n  loaderContext: LoaderContext<TFullSearchSchema, TAllParams>,\n) => Promise<any> | void\n\nexport interface LoaderContext<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> {\n  params: TAllParams\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  // parentLoaderPromise?: Promise<TParentRouteLoaderData>\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, RouteInfo<string, TPath>>,\n) => void\n\nexport type RouteOptions<\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams = {},\n> = (\n  | {\n      // The path to match (relative to the nearest parent `Route` component or root basepath)\n      path: TPath\n    }\n  | {\n      id: TRouteId\n    }\n) & {\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: GetFrameworkGeneric<'Component'> // , NoInfer<TParentAllLoaderData>>\n  // The content to be rendered when the route encounters an error\n  errorComponent?: GetFrameworkGeneric<'ErrorComponent'> // , NoInfer<TParentAllLoaderData>>\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: GetFrameworkGeneric<'Component'> //, NoInfer<TParentAllLoaderData>>\n\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: (opts: {\n    router: AnyRouter\n    match: RouteMatch\n  }) => Promise<void> | void\n\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  onLoad?: OnLoadFn<TFullSearchSchema, TAllParams>\n\n  // This function will be called if the route's loader throws an error **during an attempted navigation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  onLoadError?: (err: any) => void\n  // This function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onLoaded?: (matchContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) =>\n    | void\n    | undefined\n    | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) => void\n  // An object of whatever you want! This object is accessible anywhere matches are.\n  meta?: RouteMeta // TODO: Make this nested and mergeable\n} & (\n    | {\n        parseParams?: never\n        stringifyParams?: never\n      }\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams\n        stringifyParams: (\n          params: TParams,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? {}\n    : 'Cannot redefined path params in child routes!')\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport interface RouteConfig<\n  TId extends string = string,\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TFullPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TParentParams extends AnyPathParams = {},\n  TParams extends AnyPathParams = {},\n  TAllParams extends AnyPathParams = {},\n  TKnownChildren = unknown,\n> {\n  id: TId\n  routeId: TRouteId\n  path: NoInfer<TPath>\n  fullPath: TFullPath\n  options: RouteOptions<\n    TRouteId,\n    TPath,\n    TParentSearchSchema,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParentParams,\n    TParams,\n    TAllParams\n  >\n  children?: TKnownChildren\n  addChildren: IsAny<\n    TId,\n    any,\n    <TNewChildren extends any>(\n      children: TNewChildren extends AnyRouteConfig[]\n        ? TNewChildren\n        : { error: 'Invalid route detected'; route: TNewChildren },\n    ) => RouteConfig<\n      TId,\n      TRouteId,\n      TPath,\n      TFullPath,\n      TParentSearchSchema,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentParams,\n      TParams,\n      TAllParams,\n      TNewChildren\n    >\n  >\n  createRoute: CreateRouteConfigFn<\n    false,\n    TId,\n    TFullPath,\n    TFullSearchSchema,\n    TAllParams\n  >\n  generate: GenerateFn<TRouteId, TPath, TParentSearchSchema, TParentParams>\n}\n\ntype GenerateFn<\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TParentParams extends AnyPathParams = {},\n> = <\n  TSearchSchema extends AnySearchSchema = {},\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams> = AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams>,\n>(\n  options: Omit<\n    RouteOptions<\n      TRouteId,\n      TPath,\n      TParentSearchSchema,\n      TSearchSchema,\n      Expand<TParentSearchSchema & TSearchSchema>,\n      TParentParams,\n      TParams,\n      Expand<TParentParams & TAllParams>\n    >,\n    'path'\n  >,\n) => void\n\ntype CreateRouteConfigFn<\n  TIsRoot extends boolean = false,\n  TParentId extends string = string,\n  TParentPath extends string = string,\n  TParentRouteLoaderData extends AnyLoaderData = {},\n  TParentAllLoaderData extends AnyLoaderData = {},\n  TParentSearchSchema extends AnySearchSchema = {},\n  TParentParams extends AnyPathParams = {},\n> = <\n  TRouteId extends string,\n  TPath extends string,\n  TLoaderData extends AnyLoaderData,\n  TSearchSchema extends AnySearchSchema = AnySearchSchema,\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams> = AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams>,\n  TKnownChildren extends RouteConfig[] = RouteConfig[],\n  TResolvedId extends string = string extends TRouteId\n    ? string extends TPath\n      ? string\n      : TPath\n    : TRouteId,\n>(\n  options?: TIsRoot extends true\n    ? Omit<\n        RouteOptions<\n          TRouteId,\n          TPath,\n          TParentSearchSchema,\n          TSearchSchema,\n          Expand<TParentSearchSchema & TSearchSchema>,\n          TParentParams,\n          TParams,\n          Expand<TParentParams & TAllParams>\n        >,\n        'path'\n      > & { path?: never }\n    : RouteOptions<\n        TRouteId,\n        TPath,\n        TParentSearchSchema,\n        TSearchSchema,\n        Expand<TParentSearchSchema & TSearchSchema>,\n        TParentParams,\n        TParams,\n        Expand<TParentParams & TAllParams>\n      >,\n  children?: TKnownChildren,\n  isRoot?: boolean,\n  parentId?: string,\n  parentPath?: string,\n) => RouteConfig<\n  RoutePrefix<TParentId, TResolvedId>,\n  TResolvedId,\n  TPath,\n  string extends TPath ? '' : RoutePath<RoutePrefix<TParentPath, TPath>>,\n  TParentSearchSchema,\n  TSearchSchema,\n  Expand<TParentSearchSchema & TSearchSchema>,\n  TParentParams,\n  TParams,\n  Expand<TParentParams & TAllParams>,\n  TKnownChildren\n>\n\ntype RoutePath<T extends string> = T extends RootRouteId\n  ? '/'\n  : TrimPathRight<`${T}`>\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TId extends string,\n> = string extends TId\n  ? RootRouteId\n  : TId extends string\n  ? `${TPrefix}/${TId}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}`\n  : never\n\nexport interface AnyRouteConfig\n  extends RouteConfig<any, any, any, any, any, any, any, any, any, any, any> {}\n\nexport interface AnyRouteConfigWithChildren<TChildren>\n  extends RouteConfig<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    TChildren\n  > {}\n\ntype TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\ntype TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}`\n  ? TrimPathLeft<U>\n  : T extends `/${infer U}`\n  ? TrimPathLeft<U>\n  : T\ntype TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\nexport const createRouteConfig: CreateRouteConfigFn<true> = (\n  options = {} as any,\n  children = [] as any,\n  isRoot = true,\n  parentId,\n  parentPath,\n) => {\n  if (isRoot) {\n    ;(options as any).path = rootRouteId\n  }\n\n  // Strip the root from parentIds\n  if (parentId === rootRouteId) {\n    parentId = ''\n  }\n\n  let path: undefined | string = isRoot ? rootRouteId : options.path\n\n  // If the path is anything other than an index path, trim it up\n  if (path && path !== '/') {\n    path = trimPath(path)\n  }\n\n  const routeId = path || (options as { id?: string }).id\n\n  let id = joinPaths([parentId, routeId])\n\n  if (path === rootRouteId) {\n    path = '/'\n  }\n\n  if (id !== rootRouteId) {\n    id = joinPaths(['/', id])\n  }\n\n  const fullPath =\n    id === rootRouteId ? '/' : trimPathRight(joinPaths([parentPath, path]))\n\n  return {\n    id: id as any,\n    routeId: routeId as any,\n    path: path as any,\n    fullPath: fullPath as any,\n    options: options as any,\n    children,\n    addChildren: (children: any) =>\n      createRouteConfig(options, children, false, parentId, parentPath),\n    createRoute: (childOptions: any) =>\n      createRouteConfig(childOptions, undefined, false, id, fullPath) as any,\n    generate: () => {\n      invariant(\n        false,\n        `routeConfig.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `,\n      )\n    },\n  }\n}\n","/**\n * store\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Store {\n  listeners = new Set();\n  batching = false;\n  queue = [];\n  constructor(initialState, options) {\n    this.state = initialState;\n    this.options = options;\n  }\n  subscribe = listener => {\n    this.listeners.add(listener);\n    const unsub = this.options?.onSubscribe?.(listener, this);\n    return () => {\n      this.listeners.delete(listener);\n      unsub?.();\n    };\n  };\n  setState = updater => {\n    const previous = this.state;\n    this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);\n    this.queue.push(() => {\n      this.listeners.forEach(listener => listener(this.state, previous));\n      this.options?.onUpdate?.(this.state, previous);\n    });\n    this.#flush();\n  };\n  #flush = () => {\n    if (this.batching) return;\n    this.queue.forEach(cb => cb());\n    this.queue = [];\n  };\n  batch = cb => {\n    this.batching = true;\n    cb();\n    this.batching = false;\n    this.#flush();\n  };\n}\n\nexport { Store };\n//# sourceMappingURL=index.js.map\n","import { Store } from '@tanstack/store'\n//\nimport { GetFrameworkGeneric } from './frameworks'\nimport { Route } from './route'\nimport {\n  AnyAllRouteInfo,\n  AnyRouteInfo,\n  DefaultAllRouteInfo,\n  RouteInfo,\n} from './routeInfo'\nimport { AnyRouter, Router } from './router'\nimport { Expand } from './utils'\n\nexport interface RouteMatchStore<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n> {\n  routeSearch: TRouteInfo['searchSchema']\n  search: Expand<\n    TAllRouteInfo['fullSearchSchema'] & TRouteInfo['fullSearchSchema']\n  >\n  status: 'idle' | 'pending' | 'success' | 'error'\n  error?: unknown\n  updatedAt: number\n}\n\nconst componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport class RouteMatch<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n> {\n  route!: Route<TAllRouteInfo, TRouteInfo>\n  router!: Router<TAllRouteInfo['routeConfig'], TAllRouteInfo>\n  store!: Store<RouteMatchStore<TAllRouteInfo, TRouteInfo>>\n  id!: string\n  pathname!: string\n  params!: TRouteInfo['allParams']\n\n  component: GetFrameworkGeneric<'Component'>\n  errorComponent: GetFrameworkGeneric<'ErrorComponent'>\n  pendingComponent: GetFrameworkGeneric<'Component'>\n  abortController = new AbortController()\n  onLoaderDataListeners = new Set<() => void>()\n  parentMatch?: RouteMatch\n\n  __loadPromise?: Promise<void>\n  __onExit?:\n    | void\n    | ((matchContext: {\n        params: TRouteInfo['allParams']\n        search: TRouteInfo['fullSearchSchema']\n      }) => void)\n\n  constructor(\n    router: AnyRouter,\n    route: Route<TAllRouteInfo, TRouteInfo>,\n    opts: {\n      id: string\n      params: TRouteInfo['allParams']\n      pathname: string\n    },\n  ) {\n    Object.assign(this, {\n      route,\n      router,\n      id: opts.id,\n      pathname: opts.pathname,\n      params: opts.params,\n      store: new Store<RouteMatchStore<TAllRouteInfo, TRouteInfo>>({\n        updatedAt: 0,\n        routeSearch: {},\n        search: {} as any,\n        status: 'idle',\n      }),\n    })\n\n    if (!this.#hasLoaders()) {\n      this.store.setState((s) => ({\n        ...s,\n        status: 'success',\n      }))\n    }\n  }\n\n  cancel = () => {\n    this.abortController?.abort()\n  }\n\n  load = async (): Promise<void> => {\n    // If the match is invalid, errored or idle, trigger it to load\n    if (this.store.state.status !== 'pending') {\n      await this.fetch()\n    }\n  }\n\n  #latestId = ''\n\n  fetch = async (): Promise<void> => {\n    this.__loadPromise = Promise.resolve().then(async () => {\n      const loadId = '' + Date.now() + Math.random()\n      this.#latestId = loadId\n\n      const checkLatest = () => {\n        return loadId !== this.#latestId ? this.__loadPromise : undefined\n      }\n\n      let latestPromise\n\n      this.store.batch(() => {\n        // If the match was in an error state, set it\n        // to a loading state again. Otherwise, keep it\n        // as loading or resolved\n        if (this.store.state.status === 'idle') {\n          this.store.setState((s) => ({\n            ...s,\n            status: 'pending',\n          }))\n        }\n      })\n\n      const componentsPromise = (async () => {\n        // then run all component and data loaders in parallel\n        // For each component type, potentially load it asynchronously\n\n        await Promise.all(\n          componentTypes.map(async (type) => {\n            const component = this.route.options[type]\n\n            if (this[type]?.preload) {\n              this[type] = await this.router.options.loadComponent!(component)\n            }\n          }),\n        )\n      })()\n\n      const dataPromise = Promise.resolve().then(() => {\n        if (this.route.options.onLoad) {\n          return this.route.options.onLoad({\n            params: this.params,\n            search: this.store.state.search,\n            signal: this.abortController.signal,\n          })\n        }\n        return\n      })\n\n      try {\n        await componentsPromise\n        await dataPromise\n        if ((latestPromise = checkLatest())) return await latestPromise\n        this.store.setState((s) => ({\n          ...s,\n          error: undefined,\n          status: 'success',\n          updatedAt: Date.now(),\n        }))\n      } catch (err) {\n        this.store.setState((s) => ({\n          ...s,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now(),\n        }))\n      } finally {\n        delete this.__loadPromise\n      }\n    })\n\n    return this.__loadPromise\n  }\n\n  #hasLoaders = () => {\n    return !!(\n      this.route.options.onLoad ||\n      componentTypes.some((d) => this.route.options[d]?.preload)\n    )\n  }\n\n  __setParentMatch = (parentMatch?: RouteMatch) => {\n    if (!this.parentMatch && parentMatch) {\n      this.parentMatch = parentMatch\n    }\n  }\n\n  __validate = () => {\n    // Validate the search params and stabilize them\n    const parentSearch =\n      this.parentMatch?.store.state.search ??\n      this.router.store.state.latestLocation.search\n\n    try {\n      const validator =\n        typeof this.route.options.validateSearch === 'object'\n          ? this.route.options.validateSearch.parse\n          : this.route.options.validateSearch\n\n      let nextSearch = validator?.(parentSearch) ?? {}\n\n      this.store.setState((s) => ({\n        ...s,\n        routeSearch: nextSearch,\n        search: {\n          ...parentSearch,\n          ...nextSearch,\n        } as any,\n      }))\n\n      componentTypes.map(async (type) => {\n        const component = this.route.options[type]\n\n        if (typeof this[type] !== 'function') {\n          this[type] = component\n        }\n      })\n    } catch (err: any) {\n      console.error(err)\n      const error = new (Error as any)('Invalid search params found', {\n        cause: err,\n      })\n      error.code = 'INVALID_SEARCH_PARAMS'\n\n      this.store.setState((s) => ({\n        ...s,\n        status: 'error',\n        error: error,\n      }))\n\n      // Do not proceed with loading the route\n      return\n    }\n  }\n}\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './routeConfig'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n","import { Store } from '@tanstack/store'\nimport invariant from 'tiny-invariant'\n\n//\n\nimport { GetFrameworkGeneric } from './frameworks'\n\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ToOptions,\n  ValidFromPath,\n  ResolveRelativePath,\n} from './link'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  resolvePath,\n  trimPath,\n} from './path'\nimport { AnyRoute, Route } from './route'\nimport {\n  AnyPathParams,\n  AnyRouteConfig,\n  AnySearchSchema,\n  LoaderContext,\n  RouteConfig,\n  SearchFilter,\n} from './routeConfig'\nimport {\n  AllRouteInfo,\n  AnyAllRouteInfo,\n  RouteInfo,\n  RoutesById,\n} from './routeInfo'\nimport { RouteMatch, RouteMatchStore } from './routeMatch'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  functionalUpdate,\n  last,\n  NoInfer,\n  pick,\n  PickAsRequired,\n  PickRequired,\n  Timeout,\n  Updater,\n  replaceEqualDeep,\n} from './utils'\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  RouterHistory,\n} from './history'\n\nexport interface RegisterRouter {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any, any>\n\nexport type RegisteredRouter = RegisterRouter extends {\n  router: Router<infer TRouteConfig, infer TAllRouteInfo, infer TRouterContext>\n}\n  ? Router<TRouteConfig, TAllRouteInfo, TRouterContext>\n  : Router\n\nexport type RegisteredAllRouteInfo = RegisterRouter extends {\n  router: Router<infer TRouteConfig, infer TAllRouteInfo, infer TRouterContext>\n}\n  ? TAllRouteInfo\n  : AnyAllRouteInfo\n\nexport interface LocationState {}\n\nexport interface ParsedLocation<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  href: string\n  pathname: string\n  search: TSearchObj\n  searchStr: string\n  state: TState\n  hash: string\n  key?: string\n}\n\nexport interface FromLocation {\n  pathname: string\n  search?: unknown\n  key?: string\n  hash?: string\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\nexport type FilterRoutesFn = <TRoute extends Route<any, RouteInfo>>(\n  routeConfigs: TRoute[],\n) => TRoute[]\n\nexport interface RouterOptions<\n  TRouteConfig extends AnyRouteConfig,\n  TRouterContext,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  filterRoutes?: FilterRoutesFn\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: GetFrameworkGeneric<'Component'>\n  defaultErrorComponent?: GetFrameworkGeneric<'ErrorComponent'>\n  defaultPendingComponent?: GetFrameworkGeneric<'Component'>\n  defaultLoaderMaxAge?: number\n  defaultLoaderGcMaxAge?: number\n  caseSensitive?: boolean\n  routeConfig?: TRouteConfig\n  basepath?: string\n  Router?: (router: AnyRouter) => void\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  context?: TRouterContext\n  loadComponent?: (\n    component: GetFrameworkGeneric<'Component'>,\n  ) => Promise<GetFrameworkGeneric<'Component'>>\n  onRouteChange?: () => void\n  fetchServerDataFn?: FetchServerDataFn\n}\n\ntype FetchServerDataFn = (ctx: {\n  router: AnyRouter\n  routeMatch: RouteMatch\n}) => Promise<any>\n\nexport interface LoaderState<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> {\n  loadedAt: number\n  loaderContext: LoaderContext<TFullSearchSchema, TAllParams>\n}\n\nexport interface RouterStore<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  status: 'idle' | 'pending'\n  latestLocation: ParsedLocation<TSearchObj, TState>\n  currentMatches: RouteMatch[]\n  currentLocation: ParsedLocation<TSearchObj, TState>\n  pendingMatches?: RouteMatch[]\n  pendingLocation?: ParsedLocation<TSearchObj, TState>\n  lastUpdated: number\n}\n\nexport type ListenerFn = () => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: LocationState\n  key?: string\n  from?: string\n  fromCurrent?: boolean\n  __preSearchFilters?: SearchFilter<any>[]\n  __postSearchFilters?: SearchFilter<any>[]\n}\n\nexport type MatchCacheEntry = {\n  gc: number\n  match: RouteMatch\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n  fromCurrent?: boolean\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  fuzzy?: boolean\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport interface DehydratedRouterState\n  extends Pick<\n    RouterStore,\n    'status' | 'latestLocation' | 'currentLocation' | 'lastUpdated'\n  > {\n  currentMatches: DehydratedRouteMatch[]\n}\n\nexport interface DehydratedRouter<TRouterContext = unknown> {\n  // location: Router['__location']\n  state: DehydratedRouterState\n  context: TRouterContext\n}\n\nexport type MatchCache = Record<string, MatchCacheEntry>\n\ninterface DehydratedRouteMatch {\n  id: string\n  state: Pick<RouteMatchStore<any, any>, 'status'>\n}\n\nexport interface RouterContext {}\n\nexport const defaultFetchServerDataFn: FetchServerDataFn = async ({\n  router,\n  routeMatch,\n}) => {\n  const next = router.buildNext({\n    to: '.',\n    search: (d: any) => ({\n      ...(d ?? {}),\n      __data: {\n        matchId: routeMatch.id,\n      },\n    }),\n  })\n\n  const res = await fetch(next.href, {\n    method: 'GET',\n    signal: routeMatch.abortController.signal,\n  })\n\n  if (res.ok) {\n    return res.json()\n  }\n\n  throw new Error('Failed to fetch match data')\n}\n\nexport class Router<\n  TRouteConfig extends AnyRouteConfig = RouteConfig,\n  TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>,\n  TRouterContext = unknown,\n> {\n  types!: {\n    // Super secret internal stuff\n    RouteConfig: TRouteConfig\n    AllRouteInfo: TAllRouteInfo\n  }\n\n  options: PickAsRequired<\n    RouterOptions<TRouteConfig, TRouterContext>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  #unsubHistory?: () => void\n  basepath: string\n  // __location: Location<TAllRouteInfo['fullSearchSchema']>\n  routeTree!: Route<TAllRouteInfo, RouteInfo>\n  routesById!: RoutesById<TAllRouteInfo>\n  navigateTimeout: undefined | Timeout\n  nextAction: undefined | 'push' | 'replace'\n  navigationPromise: undefined | Promise<void>\n\n  store: Store<RouterStore<TAllRouteInfo['fullSearchSchema']>>\n  startedLoadingAt = Date.now()\n  resolveNavigation = () => {}\n\n  constructor(options?: RouterOptions<TRouteConfig, TRouterContext>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,\n    }\n\n    this.store = new Store(getInitialRouterState())\n    this.basepath = ''\n\n    this.update(options)\n\n    // Allow frameworks to hook into the router creation\n    this.options.Router?.(this)\n  }\n\n  reset = () => {\n    this.store.setState((s) => Object.assign(s, getInitialRouterState()))\n  }\n\n  mount = () => {\n    // Mount only does anything on the client\n    if (!isServer) {\n      // If the router matches are empty, load the matches\n      if (!this.store.state.currentMatches.length) {\n        this.load()\n      }\n\n      const visibilityChangeEvent = 'visibilitychange'\n      const focusEvent = 'focus'\n\n      // addEventListener does not exist in React Native, but window does\n      // In the future, we might need to invert control here for more adapters\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (window.addEventListener) {\n        // Listen to visibilitychange and focus\n        window.addEventListener(visibilityChangeEvent, this.#onFocus, false)\n        window.addEventListener(focusEvent, this.#onFocus, false)\n      }\n\n      return () => {\n        if (window.removeEventListener) {\n          // Be sure to unsubscribe if a new handler is set\n\n          window.removeEventListener(visibilityChangeEvent, this.#onFocus)\n          window.removeEventListener(focusEvent, this.#onFocus)\n        }\n      }\n    }\n\n    return () => {}\n  }\n\n  update = <\n    TRouteConfig extends RouteConfig = RouteConfig,\n    TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>,\n    TRouterContext = unknown,\n  >(\n    opts?: RouterOptions<TRouteConfig, TRouterContext>,\n  ): Router<TRouteConfig, TAllRouteInfo, TRouterContext> => {\n    Object.assign(this.options, opts)\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (this.#unsubHistory) {\n        this.#unsubHistory()\n      }\n\n      this.history =\n        this.options.history ??\n        (isServer ? createMemoryHistory() : createBrowserHistory()!)\n\n      this.store.setState((s) => ({\n        ...s,\n        latestLocation: this.#parseLocation(),\n        currentLocation: s.latestLocation,\n      }))\n\n      this.#unsubHistory = this.history.listen(() => {\n        this.load(this.#parseLocation(this.store.state.latestLocation))\n      })\n    }\n\n    const { basepath, routeConfig } = this.options\n\n    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`\n\n    if (routeConfig) {\n      this.routesById = {} as any\n      this.routeTree = this.#buildRouteTree(routeConfig)\n    }\n\n    return this as any\n  }\n\n  buildNext = (opts: BuildNextOptions) => {\n    const next = this.#buildLocation(opts)\n\n    const matches = this.matchRoutes(next.pathname)\n\n    const __preSearchFilters = matches\n      .map((match) => match.route.options.preSearchFilters ?? [])\n      .flat()\n      .filter(Boolean)\n\n    const __postSearchFilters = matches\n      .map((match) => match.route.options.postSearchFilters ?? [])\n      .flat()\n      .filter(Boolean)\n\n    return this.#buildLocation({\n      ...opts,\n      __preSearchFilters,\n      __postSearchFilters,\n    })\n  }\n\n  cancelMatches = () => {\n    ;[\n      ...this.store.state.currentMatches,\n      ...(this.store.state.pendingMatches || []),\n    ].forEach((match) => {\n      match.cancel()\n    })\n  }\n\n  load = async (next?: ParsedLocation) => {\n    let now = Date.now()\n    const startedAt = now\n    this.startedLoadingAt = startedAt\n\n    // Cancel any pending matches\n    this.cancelMatches()\n\n    let matches!: RouteMatch<any, any>[]\n\n    this.store.batch(() => {\n      if (next) {\n        // Ingest the new location\n        this.store.setState((s) => ({\n          ...s,\n          latestLocation: next,\n        }))\n      }\n\n      // Match the routes\n      matches = this.matchRoutes(this.store.state.latestLocation.pathname, {\n        strictParseParams: true,\n      })\n\n      this.store.setState((s) => ({\n        ...s,\n        status: 'pending',\n        pendingMatches: matches,\n        pendingLocation: this.store.state.latestLocation,\n      }))\n    })\n\n    // Load the matches\n    try {\n      await this.loadMatches(matches)\n    } catch (err: any) {\n      console.warn(err)\n      invariant(\n        false,\n        'Matches failed to load due to error above ☝️. Navigation cancelled!',\n      )\n    }\n\n    if (this.startedLoadingAt !== startedAt) {\n      // Ignore side-effects of outdated side-effects\n      return this.navigationPromise\n    }\n\n    const previousMatches = this.store.state.currentMatches\n\n    const exiting: RouteMatch[] = [],\n      staying: RouteMatch[] = []\n\n    previousMatches.forEach((d) => {\n      if (matches.find((dd) => dd.id === d.id)) {\n        staying.push(d)\n      } else {\n        exiting.push(d)\n      }\n    })\n\n    const entering = matches.filter((d) => {\n      return !previousMatches.find((dd) => dd.id === d.id)\n    })\n\n    now = Date.now()\n\n    exiting.forEach((d) => {\n      d.__onExit?.({\n        params: d.params,\n        search: d.store.state.routeSearch,\n      })\n\n      // Clear non-loading error states when match leaves\n      if (d.store.state.status === 'error') {\n        this.store.setState((s) => ({\n          ...s,\n          status: 'idle',\n          error: undefined,\n        }))\n      }\n    })\n\n    staying.forEach((d) => {\n      d.route.options.onTransition?.({\n        params: d.params,\n        search: d.store.state.routeSearch,\n      })\n    })\n\n    entering.forEach((d) => {\n      d.__onExit = d.route.options.onLoaded?.({\n        params: d.params,\n        search: d.store.state.search,\n      })\n      // delete this.store.state.matchCache[d.id] // TODO:\n    })\n\n    this.store.setState((s) => ({\n      ...s,\n      status: 'idle',\n      currentLocation: this.store.state.latestLocation,\n      currentMatches: matches,\n      pendingLocation: undefined,\n      pendingMatches: undefined,\n    }))\n\n    this.options.onRouteChange?.()\n\n    this.resolveNavigation()\n  }\n\n  getRoute = <TId extends keyof TAllRouteInfo['routeInfoById']>(\n    id: TId,\n  ): Route<TAllRouteInfo, TAllRouteInfo['routeInfoById'][TId]> => {\n    const route = this.routesById[id]\n\n    invariant(route, `Route with id \"${id as string}\" not found`)\n\n    return route\n  }\n\n  loadRoute = async (\n    navigateOpts: BuildNextOptions = this.store.state.latestLocation,\n  ): Promise<RouteMatch[]> => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n    await this.loadMatches(matches)\n    return matches\n  }\n\n  preloadRoute = async (\n    navigateOpts: BuildNextOptions = this.store.state.latestLocation,\n  ) => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, {\n      strictParseParams: true,\n    })\n\n    await this.loadMatches(matches, {\n      preload: true,\n    })\n    return matches\n  }\n\n  matchRoutes = (pathname: string, opts?: { strictParseParams?: boolean }) => {\n    const matches: RouteMatch[] = []\n\n    if (!this.routeTree) {\n      return matches\n    }\n\n    const existingMatches = [\n      ...this.store.state.currentMatches,\n      ...(this.store.state.pendingMatches ?? []),\n    ]\n\n    const recurse = async (routes: Route<any, any>[]): Promise<void> => {\n      const parentMatch = last(matches)\n      let params = parentMatch?.params ?? {}\n\n      const filteredRoutes = this.options.filterRoutes?.(routes) ?? routes\n\n      let foundRoutes: Route[] = []\n\n      const findMatchInRoutes = (parentRoutes: Route[], routes: Route[]) => {\n        routes.some((route) => {\n          if (!route.path && route.childRoutes?.length) {\n            return findMatchInRoutes([...foundRoutes, route], route.childRoutes)\n          }\n\n          const fuzzy = !!(route.path !== '/' || route.childRoutes?.length)\n\n          const matchParams = matchPathname(this.basepath, pathname, {\n            to: route.fullPath,\n            fuzzy,\n            caseSensitive:\n              route.options.caseSensitive ?? this.options.caseSensitive,\n          })\n\n          if (matchParams) {\n            let parsedParams\n\n            try {\n              parsedParams =\n                route.options.parseParams?.(matchParams!) ?? matchParams\n            } catch (err) {\n              if (opts?.strictParseParams) {\n                throw err\n              }\n            }\n\n            params = {\n              ...params,\n              ...parsedParams,\n            }\n          }\n\n          if (!!matchParams) {\n            foundRoutes = [...parentRoutes, route]\n          }\n\n          return !!foundRoutes.length\n        })\n\n        return !!foundRoutes.length\n      }\n\n      findMatchInRoutes([], filteredRoutes)\n\n      if (!foundRoutes.length) {\n        return\n      }\n\n      foundRoutes.forEach((foundRoute) => {\n        const interpolatedPath = interpolatePath(foundRoute.path, params)\n        const matchId = interpolatePath(foundRoute.id, params, true)\n\n        const match =\n          existingMatches.find((d) => d.id === matchId) ||\n          // this.store.state.matchCache[matchId]?.match || // TODO:\n          new RouteMatch(this, foundRoute, {\n            id: matchId,\n            params,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n          })\n\n        matches.push(match)\n      })\n\n      const foundRoute = last(foundRoutes)!\n\n      if (foundRoute.childRoutes?.length) {\n        recurse(foundRoute.childRoutes)\n      }\n    }\n\n    recurse([this.routeTree])\n\n    linkMatches(matches)\n\n    return matches\n  }\n\n  loadMatches = async (\n    resolvedMatches: RouteMatch[],\n    loaderOpts?: { preload?: boolean },\n  ) => {\n    // this.cleanMatchCache()\n    resolvedMatches.forEach(async (match) => {\n      // Validate the match (loads search params etc)\n      match.__validate()\n    })\n\n    // Check each match middleware to see if the route can be accessed\n    await Promise.all(\n      resolvedMatches.map(async (match) => {\n        try {\n          await match.route.options.beforeLoad?.({\n            router: this as any,\n            match,\n          })\n        } catch (err) {\n          if (!loaderOpts?.preload) {\n            match.route.options.onLoadError?.(err)\n          }\n\n          throw err\n        }\n      }),\n    )\n\n    const matchPromises = resolvedMatches.map(async (match, index) => {\n      const prevMatch = resolvedMatches[(index = 1)]\n      const search = match.store.state.search as { __data?: any }\n\n      if (search.__data?.matchId && search.__data.matchId !== match.id) {\n        return\n      }\n\n      match.load()\n\n      if (match.store.state.status !== 'success' && match.__loadPromise) {\n        // Wait for the first sign of activity from the match\n        await match.__loadPromise\n      }\n\n      if (prevMatch) {\n        await prevMatch.__loadPromise\n      }\n    })\n\n    await Promise.all(matchPromises)\n  }\n\n  reload = () => {\n    this.navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true,\n    } as any)\n  }\n\n  resolvePath = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  navigate = async <\n    TFrom extends ValidFromPath<TAllRouteInfo> = '/',\n    TTo extends string = '.',\n  >({\n    from,\n    to = '.' as any,\n    search,\n    hash,\n    replace,\n    params,\n  }: NavigateOptions<TAllRouteInfo, TFrom, TTo>) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.#commitLocation({\n      from: fromString,\n      to: toString,\n      search,\n      hash,\n      replace,\n      params,\n    })\n  }\n\n  matchRoute = <\n    TFrom extends ValidFromPath<TAllRouteInfo> = '/',\n    TTo extends string = '.',\n  >(\n    location: ToOptions<TAllRouteInfo, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ):\n    | false\n    | TAllRouteInfo['routeInfoById'][ResolveRelativePath<\n        TFrom,\n        NoInfer<TTo>\n      >]['allParams'] => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePath(location.from ?? '', location.to)\n        : undefined,\n    }\n\n    const next = this.buildNext(location)\n\n    if (opts?.pending) {\n      if (!this.store.state.pendingLocation) {\n        return false\n      }\n\n      return matchPathname(\n        this.basepath,\n        this.store.state.pendingLocation!.pathname,\n        {\n          ...opts,\n          to: next.pathname,\n        },\n      ) as any\n    }\n\n    return matchPathname(\n      this.basepath,\n      this.store.state.currentLocation.pathname,\n      {\n        ...opts,\n        to: next.pathname,\n      },\n    ) as any\n  }\n\n  buildLink = <\n    TFrom extends ValidFromPath<TAllRouteInfo> = '/',\n    TTo extends string = '.',\n  >({\n    from,\n    to = '.' as any,\n    search,\n    params,\n    hash,\n    target,\n    replace,\n    activeOptions,\n    preload,\n    preloadMaxAge: userPreloadMaxAge,\n    preloadGcMaxAge: userPreloadGcMaxAge,\n    preloadDelay: userPreloadDelay,\n    disabled,\n  }: LinkOptions<TAllRouteInfo, TFrom, TTo>): LinkInfo => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to,\n      }\n    } catch (e) {}\n\n    const nextOpts = {\n      from,\n      to,\n      search,\n      params,\n      hash,\n      replace,\n    }\n\n    const next = this.buildNext(nextOpts)\n\n    preload = preload ?? this.options.defaultPreload\n    const preloadDelay =\n      userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const pathIsEqual =\n      this.store.state.currentLocation.pathname === next.pathname\n    const currentPathSplit =\n      this.store.state.currentLocation.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    const hashIsEqual = this.store.state.currentLocation.hash === next.hash\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact ? pathIsEqual : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash ? hashIsEqual : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        this.#commitLocation(nextOpts as any)\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        this.preloadRoute(nextOpts).catch((err) => {\n          console.warn(err)\n          console.warn('Error preloading route! ☝️')\n        })\n      }\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          this.preloadRoute(nextOpts).catch((err) => {\n            console.warn(err)\n            console.warn('Error preloading route! ☝️')\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      isActive,\n      disabled,\n    }\n  }\n\n  dehydrate = (): DehydratedRouter<TRouterContext> => {\n    return {\n      state: {\n        ...pick(this.store.state, [\n          'latestLocation',\n          'currentLocation',\n          'status',\n          'lastUpdated',\n        ]),\n        currentMatches: this.store.state.currentMatches.map((match) => ({\n          id: match.id,\n          state: {\n            ...pick(match.store.state, ['status']),\n          },\n        })),\n      },\n      context: this.options.context as TRouterContext,\n    }\n  }\n\n  hydrate = (dehydratedRouter: DehydratedRouter<TRouterContext>) => {\n    this.store.setState((s) => {\n      this.options.context = dehydratedRouter.context\n\n      // Match the routes\n      const currentMatches = this.matchRoutes(\n        dehydratedRouter.state.latestLocation.pathname,\n        {\n          strictParseParams: true,\n        },\n      )\n\n      currentMatches.forEach((match, index) => {\n        const dehydratedMatch = dehydratedRouter.state.currentMatches[index]\n        invariant(\n          dehydratedMatch && dehydratedMatch.id === match.id,\n          'Oh no! There was a hydration mismatch when attempting to hydrate the state of the router! 😬',\n        )\n        match.store.setState((s) => ({\n          ...s,\n          ...dehydratedMatch.state,\n        }))\n      })\n\n      currentMatches.forEach((match) => match.__validate())\n\n      return {\n        ...s,\n        ...dehydratedRouter.state,\n        currentMatches,\n      }\n    })\n  }\n\n  #buildRouteTree = (rootRouteConfig: RouteConfig) => {\n    const recurseRoutes = (\n      routeConfigs: RouteConfig[],\n      parent?: Route<TAllRouteInfo, any, any>,\n    ): Route<TAllRouteInfo, any, any>[] => {\n      return routeConfigs.map((routeConfig, i) => {\n        const routeOptions = routeConfig.options\n        const route = new Route(routeConfig, routeOptions, i, parent, this)\n        const existingRoute = (this.routesById as any)[route.id]\n\n        if (existingRoute) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `Duplicate routes found with id: ${String(route.id)}`,\n              this.routesById,\n              route,\n            )\n          }\n          throw new Error()\n        }\n\n        ;(this.routesById as any)[route.id] = route\n\n        const children = routeConfig.children as RouteConfig[]\n\n        route.childRoutes = children.length\n          ? recurseRoutes(children, route)\n          : undefined\n\n        return route\n      })\n    }\n\n    const routes = recurseRoutes([rootRouteConfig])\n\n    return routes[0]!\n  }\n\n  #parseLocation = (previousLocation?: ParsedLocation): ParsedLocation => {\n    let { pathname, search, hash, state } = this.history.location\n\n    const parsedSearch = this.options.parseSearch(search)\n\n    return {\n      pathname: pathname,\n      searchStr: search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: hash.split('#').reverse()[0] ?? '',\n      href: `${pathname}${search}${hash}`,\n      state: state as LocationState,\n      key: state?.key || '__init__',\n    }\n  }\n\n  #onFocus = () => {\n    this.load()\n  }\n\n  #buildLocation = (dest: BuildNextOptions = {}): ParsedLocation => {\n    const fromPathname = dest.fromCurrent\n      ? this.store.state.latestLocation.pathname\n      : dest.from ?? this.store.state.latestLocation.pathname\n\n    let pathname = resolvePath(\n      this.basepath ?? '/',\n      fromPathname,\n      `${dest.to ?? '.'}`,\n    )\n\n    const fromMatches = this.matchRoutes(\n      this.store.state.latestLocation.pathname,\n      {\n        strictParseParams: true,\n      },\n    )\n\n    const toMatches = this.matchRoutes(pathname)\n\n    const prevParams = { ...last(fromMatches)?.params }\n\n    let nextParams =\n      (dest.params ?? true) === true\n        ? prevParams\n        : functionalUpdate(dest.params!, prevParams)\n\n    if (nextParams) {\n      toMatches\n        .map((d) => d.route.options.stringifyParams)\n        .filter(Boolean)\n        .forEach((fn) => {\n          Object.assign({}, nextParams!, fn!(nextParams!))\n        })\n    }\n\n    pathname = interpolatePath(pathname, nextParams ?? {})\n\n    // Pre filters first\n    const preFilteredSearch = dest.__preSearchFilters?.length\n      ? dest.__preSearchFilters?.reduce(\n          (prev, next) => next(prev),\n          this.store.state.latestLocation.search,\n        )\n      : this.store.state.latestLocation.search\n\n    // Then the link/navigate function\n    const destSearch =\n      dest.search === true\n        ? preFilteredSearch // Preserve resolvedFrom true\n        : dest.search\n        ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n        : dest.__preSearchFilters?.length\n        ? preFilteredSearch // Preserve resolvedFrom filters\n        : {}\n\n    // Then post filters\n    const postFilteredSearch = dest.__postSearchFilters?.length\n      ? dest.__postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n      : destSearch\n\n    const search = replaceEqualDeep(\n      this.store.state.latestLocation.search,\n      postFilteredSearch,\n    )\n\n    const searchStr = this.options.stringifySearch(search)\n    let hash =\n      dest.hash === true\n        ? this.store.state.latestLocation.hash\n        : functionalUpdate(dest.hash!, this.store.state.latestLocation.hash)\n    hash = hash ? `#${hash}` : ''\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: this.store.state.latestLocation.state,\n      hash,\n      href: `${pathname}${searchStr}${hash}`,\n      key: dest.key,\n    }\n  }\n\n  #commitLocation = (location: BuildNextOptions & { replace?: boolean }) => {\n    const next = this.buildNext(location)\n    const id = '' + Date.now() + Math.random()\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!location.replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl = this.store.state.latestLocation.href === next.href\n\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace'\n    }\n\n    const href = `${next.pathname}${next.searchStr}${\n      next.hash ? `#${next.hash}` : ''\n    }`\n\n    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {\n      id,\n      ...next.state,\n    })\n\n    // this.load(this.#parseLocation(this.store.state.latestLocation))\n\n    return (this.navigationPromise = new Promise((resolve) => {\n      const previousNavigationResolve = this.resolveNavigation\n\n      this.resolveNavigation = () => {\n        previousNavigationResolve()\n        resolve()\n      }\n    }))\n  }\n}\n\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !window.document.createElement\n\nfunction getInitialRouterState(): RouterStore {\n  return {\n    status: 'idle',\n    latestLocation: null!,\n    currentLocation: null!,\n    currentMatches: [],\n    lastUpdated: Date.now(),\n    // matchCache: {}, // TODO:\n    // get isFetching() {\n    //   return (\n    //     this.status === 'loading' ||\n    //     this.currentMatches.some((d) => d.store.state.isFetching)\n    //   )\n    // },\n    // get isPreloading() {\n    //   return Object.values(this.matchCache).some(\n    //     (d) =>\n    //       d.match.store.state.isFetching &&\n    //       !this.currentMatches.find((dd) => dd.id === d.match.id),\n    //   )\n    // },\n  }\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nfunction linkMatches(matches: RouteMatch<any, any>[]) {\n  matches.forEach((match, index) => {\n    const parent = matches[index - 1]\n\n    if (parent) {\n      match.__setParentMatch(parent)\n    }\n  })\n}\n"],"names":["invariant","condition","message","Error","popStateEvent","createHistory","opts","currentLocation","getLocation","unsub","listeners","Set","onUpdate","forEach","listener","location","listen","cb","size","add","delete","push","path","state","pushState","replace","replaceState","go","index","back","forward","createBrowserHistory","getHref","window","pathname","hash","search","createHref","parseLocation","history","addEventListener","removeEventListener","key","createRandomKey","n","createMemoryHistory","initialEntries","entries","initialIndex","length","currentState","Math","min","href","hashIndex","indexOf","searchIndex","substring","random","toString","last","arr","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","replaceEqualDeep","prev","_next","next","array","Array","isArray","isPlainObject","prevSize","Object","nextItems","nextSize","copy","equalItems","i","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","call","joinPaths","paths","cleanPath","filter","Boolean","join","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","toSegment","value","pop","map","d","segments","slice","type","split","part","startsWith","charAt","interpolatePath","params","leaveWildcard","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","routeSegments","max","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","caseSensitive","toLowerCase","fuzzy","undefined","encode","pfx","k","tmp","str","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","shift","concat","Route","routeConfig","options","originalIndex","router","assign","this","getRouter","childRoutes","getParentRoute","createRoute","route","rootRouteId","createRouteConfig","children","isRoot","parentId","parentPath","routeId","id","fullPath","addChildren","childOptions","generate","Store","batching","queue","initialState","subscribe","onSubscribe","setState","updateFn","flush","batch","componentTypes","RouteMatch","abortController","AbortController","onLoaderDataListeners","store","updatedAt","routeSearch","status","hasLoaders","s","cancel","abort","load","async","fetch","latestId","__loadPromise","Promise","resolve","then","loadId","Date","now","checkLatest","latestPromise","componentsPromise","all","component","preload","loadComponent","dataPromise","onLoad","signal","error","err","some","__setParentMatch","parentMatch","__validate","parentSearch","latestLocation","nextSearch","validateSearch","parse","console","cause","code","defaultParseSearch","parseSearchWith","JSON","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","val","defaultFetchServerDataFn","routeMatch","buildNext","__data","matchId","res","method","ok","json","isServer","document","createElement","getInitialRouterState","currentMatches","lastUpdated","unsubHistory","startedLoadingAt","resolveNavigation","defaultPreloadDelay","context","stringifySearch","parseSearch","fetchServerDataFn","update","Router","reset","mount","visibilityChangeEvent","focusEvent","onFocus","routesById","routeTree","buildRouteTree","buildLocation","matches","matchRoutes","__preSearchFilters","match","preSearchFilters","flat","__postSearchFilters","postSearchFilters","cancelMatches","pendingMatches","startedAt","strictParseParams","pendingLocation","loadMatches","warn","navigationPromise","previousMatches","exiting","staying","find","dd","entering","__onExit","onTransition","onLoaded","onRouteChange","getRoute","loadRoute","navigateOpts","preloadRoute","existingMatches","recurse","filteredRoutes","filterRoutes","routes","foundRoutes","findMatchInRoutes","parentRoutes","matchParams","parsedParams","parseParams","foundRoute","interpolatedPath","linkMatches","resolvedMatches","loaderOpts","beforeLoad","onLoadError","matchPromises","prevMatch","reload","navigate","fromCurrent","String","fromString","isExternal","URL","e","commitLocation","matchRoute","pending","buildLink","target","activeOptions","preloadMaxAge","userPreloadMaxAge","preloadGcMaxAge","userPreloadGcMaxAge","preloadDelay","userPreloadDelay","disabled","nextOpts","defaultPreload","pathIsEqual","currentPathSplit","pathIsFuzzyEqual","every","hashIsEqual","handleFocus","catch","handleClick","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","defaultPrevented","button","preventDefault","handleEnter","preloadTimeout","setTimeout","handleLeave","clearTimeout","isActive","exact","includeHash","dehydrate","hydrate","dehydratedRouter","dehydratedMatch","rootRouteConfig","recurseRoutes","routeConfigs","routeOptions","previousLocation","parsedSearch","reverse","dest","fromPathname","fromMatches","toMatches","prevParams","nextParams","stringifyParams","fn","preFilteredSearch","destSearch","postFilteredSearch","navigateTimeout","nextAction","previousNavigationResolve","cond"],"mappings":";;;;;;;;;;kPAEA,SAASA,EAAUC,EAAWC,GAC1B,IAAID,EAIA,MAAM,IAAIE,MANL,mBAWb,CCeA,MAAMC,EAAgB,WAEtB,SAASC,EAAcC,GASrB,IAAIC,EAAkBD,EAAKE,cACvBC,EAAQ,OACRC,EAAY,IAAIC,IAEpB,MAAMC,EAAW,KACfL,EAAkBD,EAAKE,cAEvBE,EAAUG,SAASC,GAAaA,KAAW,EAG7C,MAAO,CACDC,eACF,OAAOR,CACR,EACDS,OAASC,IACgB,IAAnBP,EAAUQ,OACZT,EAAQH,EAAKQ,SAASF,IAExBF,EAAUS,IAAIF,GAEP,KACLP,EAAUU,OAAOH,GACM,IAAnBP,EAAUQ,MACZT,GACF,GAGJY,KAAM,CAACC,EAAcC,KACnBjB,EAAKkB,UAAUF,EAAMC,GACrBX,GAAU,EAEZa,QAAS,CAACH,EAAcC,KACtBjB,EAAKoB,aAAaJ,EAAMC,GACxBX,GAAU,EAEZe,GAAKC,IACHtB,EAAKqB,GAAGC,GACRhB,GAAU,EAEZiB,KAAM,KACJvB,EAAKuB,OACLjB,GAAU,EAEZkB,QAAS,KACPxB,EAAKwB,UACLlB,GAAU,EAGhB,CAEO,SAASmB,EAAqBzB,GAInC,MAAM0B,EACJ1B,GAAM0B,SAAO,KAEV,GAAEC,OAAOlB,SAASmB,WAAWD,OAAOlB,SAASoB,OAAOF,OAAOlB,SAASqB,UACnEC,EAAa/B,GAAM+B,YAAU,CAAMf,GAASA,GAGlD,OAAOjB,EAAc,CACnBG,YAHkB,IAAM8B,EAAcN,IAAWO,QAAQhB,OAIzDT,SAAWF,IACTqB,OAAOO,iBAAiBpC,EAAeQ,GAChC,KACLqB,OAAOQ,oBAAoBrC,EAAeQ,EAAS,GAGvDY,UAAW,CAACF,EAAMC,KAChBU,OAAOM,QAAQf,UACb,IAAKD,EAAOmB,IAAKC,KACjB,GACAN,EAAWf,GACZ,EAEHI,aAAc,CAACJ,EAAMC,KACnBU,OAAOM,QAAQb,aACb,IAAKH,EAAOmB,IAAKC,KACjB,GACAN,EAAWf,GACZ,EAEHO,KAAM,IAAMI,OAAOM,QAAQV,OAC3BC,QAAS,IAAMG,OAAOM,QAAQT,UAC9BH,GAAKiB,GAAMX,OAAOM,QAAQZ,GAAGiB,IAEjC,CASO,SAASC,EACdvC,EAGI,CACFwC,eAAgB,CAAC,OAGnB,MAAMC,EAAUzC,EAAKwC,eACrB,IAAIlB,EAAQtB,EAAK0C,cAAgBD,EAAQE,OAAS,EAC9CC,EAAe,CAAA,EAInB,OAAO7C,EAAc,CACnBG,YAHkB,IAAM8B,EAAcS,EAAQnB,GAASsB,GAIvDpC,SAAU,IACD,OAETU,UAAW,CAACF,EAAMC,KAChB2B,EAAe,IACV3B,EACHmB,IAAKC,KAEPI,EAAQ1B,KAAKC,GACbM,GAAO,EAETF,aAAc,CAACJ,EAAMC,KACnB2B,EAAe,IACV3B,EACHmB,IAAKC,KAEPI,EAAQnB,GAASN,CAAI,EAEvBO,KAAM,KACJD,GAAO,EAETE,QAAS,KACPF,EAAQuB,KAAKC,IAAIxB,EAAQ,EAAGmB,EAAQE,OAAS,EAAE,EAEjDtB,GAAKiB,GAAMX,OAAOM,QAAQZ,GAAGiB,IAEjC,CAEA,SAASN,EAAce,EAAc9B,GACnC,IAAI+B,EAAYD,EAAKE,QAAQ,KACzBC,EAAcH,EAAKE,QAAQ,KAE/B,MAAO,CACLF,OACAnB,SAAUmB,EAAKI,UACb,EACAH,EAAY,EACRE,EAAc,EACZL,KAAKC,IAAIE,EAAWE,GACpBF,EACFE,EAAc,EACdA,EACAH,EAAKJ,QAEXd,KAAMmB,GAAa,EAAID,EAAKI,UAAUH,EAAWE,GAAe,GAChEpB,OAAQoB,GAAe,EAAIH,EAAKI,UAAUD,GAAe,GACzDjC,QAEJ,CAGA,SAASoB,IACP,OAAQQ,KAAKO,SAAW,GAAGC,SAAS,IAAIF,UAAU,EACpD,CC7IO,SAASG,EAAQC,GACtB,OAAOA,EAAIA,EAAIZ,OAAS,EAC1B,CAkBO,SAASa,EACdC,EACAC,GAEA,MAPoB,mBAOLD,EACNA,EAAQC,GAGVD,CACT,CAEO,SAASE,EAA2BC,EAAWC,GACpD,OAAOA,EAAKC,QAAO,CAACC,EAAU3B,KAC5B2B,EAAI3B,GAAOwB,EAAOxB,GACX2B,IACN,CAAE,EACP,CAQO,SAASC,EAAoBC,EAAWC,GAC7C,GAAID,IAASC,EACX,OAAOD,EAGT,MAAME,EAAOD,EAEPE,EAAQC,MAAMC,QAAQL,IAASI,MAAMC,QAAQH,GAEnD,GAAIC,GAAUG,EAAcN,IAASM,EAAcJ,GAAQ,CACzD,MAAMK,EAAWJ,EAAQH,EAAKtB,OAAS8B,OAAOZ,KAAKI,GAAMtB,OACnD+B,EAAYN,EAAQD,EAAOM,OAAOZ,KAAKM,GACvCQ,EAAWD,EAAU/B,OACrBiC,EAAYR,EAAQ,GAAK,GAE/B,IAAIS,EAAa,EAEjB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAUG,IAAK,CACjC,MAAM1C,EAAMgC,EAAQU,EAAIJ,EAAUI,GAClCF,EAAKxC,GAAO4B,EAAiBC,EAAK7B,GAAM+B,EAAK/B,IACzCwC,EAAKxC,KAAS6B,EAAK7B,IACrByC,GAEJ,CAEA,OAAOL,IAAaG,GAAYE,IAAeL,EAAWP,EAAOW,CACnE,CAEA,OAAOT,CACT,CAGO,SAASI,EAAcQ,GAC5B,IAAKC,EAAmBD,GACtB,OAAO,EAIT,MAAME,EAAOF,EAAEG,YACf,QAAoB,IAATD,EACT,OAAO,EAIT,MAAME,EAAOF,EAAKG,UAClB,QAAKJ,EAAmBG,MAKnBA,EAAKE,eAAe,gBAM3B,CAEA,SAASL,EAAmBD,GAC1B,MAA6C,oBAAtCN,OAAOW,UAAU/B,SAASiC,KAAKP,EACxC,CC5JO,SAASQ,EAAUC,GACxB,OAAOC,EAAUD,EAAME,OAAOC,SAASC,KAAK,KAC9C,CAEO,SAASH,EAAUzE,GAExB,OAAOA,EAAKG,QAAQ,UAAW,IACjC,CAEO,SAAS0E,EAAa7E,GAC3B,MAAgB,MAATA,EAAeA,EAAOA,EAAKG,QAAQ,UAAW,GACvD,CAEO,SAAS2E,EAAc9E,GAC5B,MAAgB,MAATA,EAAeA,EAAOA,EAAKG,QAAQ,UAAW,GACvD,CAEO,SAAS4E,EAAS/E,GACvB,OAAO8E,EAAcD,EAAa7E,GACpC,CAEO,SAASgF,EAAYC,EAAkBC,EAAcC,GAC1DD,EAAOA,EAAK/E,QAAQ,IAAIiF,OAAQ,IAAGH,KAAa,KAChDE,EAAKA,EAAGhF,QAAQ,IAAIiF,OAAQ,IAAGH,KAAa,KAE5C,IAAII,EAAeC,EAAcJ,GACjC,MAAMK,EAAaD,EAAcH,GAEjCI,EAAWhG,SAAQ,CAACiG,EAAWlF,KAC7B,GAAwB,MAApBkF,EAAUC,MACPnF,EAGMA,IAAUiF,EAAW5D,OAAS,GAEvC0D,EAAatF,KAAKyF,GAHlBH,EAAe,CAACG,QAOb,GAAwB,OAApBA,EAAUC,MAEfJ,EAAa1D,OAAS,GAAmC,MAA9BW,EAAK+C,IAAeI,OACjDJ,EAAaK,MAEfL,EAAaK,UACR,IAAwB,MAApBF,EAAUC,MACnB,OAEAJ,EAAatF,KAAKyF,EACpB,KAKF,OAAOf,EAFQF,EAAU,CAACU,KAAaI,EAAaM,KAAKC,GAAMA,EAAEH,UAGnE,CAEO,SAASH,EAAc1E,GAC5B,IAAKA,EACH,MAAO,GAKT,MAAMiF,EAAsB,GAU5B,GAR6B,OAJ7BjF,EAAW6D,EAAU7D,IAIRkF,MAAM,EAAG,KACpBlF,EAAWA,EAASuB,UAAU,GAC9B0D,EAAS9F,KAAK,CACZgG,KAAM,WACNN,MAAO,QAIN7E,EACH,OAAOiF,EAIT,MAAMG,EAAQpF,EAASoF,MAAM,KAAKtB,OAAOC,SAiCzC,OA/BAkB,EAAS9F,QACJiG,EAAML,KAAKM,GACRA,EAAKC,WAAW,KACX,CACLH,KAAM,WACNN,MAAOQ,GAIY,MAAnBA,EAAKE,OAAO,GACP,CACLJ,KAAM,QACNN,MAAOQ,GAIJ,CACLF,KAAM,WACNN,MAAOQ,MAKc,MAAvBrF,EAASkF,OAAO,KAClBlF,EAAWA,EAASuB,UAAU,GAC9B0D,EAAS9F,KAAK,CACZgG,KAAM,WACNN,MAAO,OAIJI,CACT,CAEO,SAASO,EACdpG,EACAqG,EACAC,GAIA,OAAO/B,EAF0Be,EAActF,GAGpB2F,KAAKY,GACN,MAAlBA,EAAQd,OAAkBa,EAIT,UAAjBC,EAAQR,KACHM,EAAQE,EAAQd,MAAMtD,UAAU,KAAO,GAGzCoE,EAAQd,MAPN,KAUf,CAEO,SAASe,EACdvB,EACAwB,EACAC,GAEA,MAAMC,EAAaC,EAAY3B,EAAUwB,EAAiBC,GAG1D,IAAIA,EAAcvB,IAAOwB,EAIzB,OAAOA,GAAc,CAAA,CACvB,CAEO,SAASC,EACd3B,EACA4B,EACAH,GAEA,IAAKG,EAAKX,WAAWjB,GACnB,OAGF,MAAMI,EAAeC,EADrBuB,EAAmB,KAAZ5B,EAAkB4B,EAAK1E,UAAU8C,EAAStD,QAAUkF,GAGrDC,EAAgBxB,EADV,GAAEoB,EAAcvB,IAAM,OAG5BkB,EAAiC,CAAA,EA+DvC,MA7Dc,MACZ,IACE,IAAIvC,EAAI,EACRA,EAAIjC,KAAKkF,IAAI1B,EAAa1D,OAAQmF,EAAcnF,QAChDmC,IACA,CACA,MAAMkD,EAAc3B,EAAavB,GAC3BmD,EAAeH,EAAchD,GAE7BoD,EAAqBpD,IAAMgD,EAAcnF,OAAS,EAClDwF,EAAoBrD,IAAMuB,EAAa1D,OAAS,EAEtD,GAAIsF,EAAc,CAChB,GAA0B,aAAtBA,EAAalB,KACf,QAAIiB,GAAavB,QACfY,EAAO,KAAO9B,EAAUc,EAAaS,MAAMhC,GAAG6B,KAAKC,GAAMA,EAAEH,UACpD,GAKX,GAA0B,aAAtBwB,EAAalB,KAAqB,CACpC,GAA2B,MAAvBkB,EAAaxB,QAAkBuB,GAAavB,MAC9C,OAAO,EAGT,GAAIuB,EACF,GAAIN,EAAcU,eAChB,GAAIH,EAAaxB,QAAUuB,EAAYvB,MACrC,OAAO,OAEJ,GACLwB,EAAaxB,MAAM4B,gBACnBL,EAAYvB,MAAM4B,cAElB,OAAO,CAGb,CAEA,IAAKL,EACH,OAAO,EAGT,GAA0B,UAAtBC,EAAalB,KAAkB,CACjC,GAA2B,MAAvBiB,GAAavB,MACf,OAAO,EAE2B,MAAhCuB,EAAYvB,MAAMU,OAAO,KAC3BE,EAAOY,EAAaxB,MAAMtD,UAAU,IAAM6E,EAAYvB,MAE1D,CACF,CAEA,GAAIyB,IAAuBC,EACzB,QAAST,EAAcY,KAE3B,CACA,OAAO,CACR,EA3Da,GA6DIjB,OAAoCkB,CACxD,CC3OO,SAASC,EAAOzE,EAAK0E,GAC1B,IAAIC,EACF5D,EACA6D,EACAC,EAAM,GAER,IAAKF,KAAK3E,EACR,QAAuB,KAAlB4E,EAAM5E,EAAI2E,IACb,GAAIrE,MAAMC,QAAQqE,GAChB,IAAK7D,EAAI,EAAGA,EAAI6D,EAAIhG,OAAQmC,IAC1B8D,IAAQA,GAAO,KACfA,GAAOC,mBAAmBH,GAAK,IAAMG,mBAAmBF,EAAI7D,SAG9D8D,IAAQA,GAAO,KACfA,GAAOC,mBAAmBH,GAAK,IAAMG,mBAAmBF,GAK9D,OAAQF,GAAO,IAAMG,CACvB,CAEA,SAASE,EAAQC,GACf,IAAKA,EAAK,MAAO,GACjB,IAAIH,EAAMI,mBAAmBD,GAC7B,MAAY,UAARH,IACQ,SAARA,IACkB,MAAlBA,EAAIzB,OAAO,GAAmByB,EACpB,GAANA,GAAY,GAAKA,EAAMA,GACjC,CAEO,SAASK,EAAOL,GAMrB,IALA,IAAID,EACFD,EACAQ,EAAM,CAAE,EACR3F,EAAMqF,EAAI5B,MAAM,KAEV2B,EAAMpF,EAAI4F,cAGD,IAAXD,EADJR,GADAC,EAAMA,EAAI3B,MAAM,MACRmC,SAEND,EAAIR,GAAK,GAAGU,OAAOF,EAAIR,GAAII,EAAQH,EAAIQ,UAEvCD,EAAIR,GAAKI,EAAQH,EAAIQ,SAIzB,OAAOD,CACT,CC1CO,MAAMG,EAmBXnE,YACEoE,EACAC,EACAC,EACA5F,EACA6F,GAEAhF,OAAOiF,OAAOC,KAAM,IACfL,EACHE,gBACAD,UACAK,UAAW,IAAMH,EACjBI,iBAAatB,EACbuB,eAAgB,IAAMlG,IAGxB6F,EAAOF,QAAQQ,cAAc,CAAEN,SAAQO,MAAOL,MAChD,ECtCWM,MAAAA,EAAc,WAsWdC,EAA+C,CAC1DX,EAAU,CAAA,EACVY,EAAW,GACXC,GAAS,EACTC,EACAC,KAEIF,IACAb,EAAgBvI,KAAOiJ,GAIvBI,IAAaJ,IACfI,EAAW,IAGb,IAAIrJ,EAA2BoJ,EAASH,EAAcV,EAAQvI,KAG1DA,GAAiB,MAATA,IACVA,EAAO+E,EAAS/E,IAGlB,MAAMuJ,EAAUvJ,GAASuI,EAA4BiB,GAErD,IAAIA,EAAKjF,EAAU,CAAC8E,EAAUE,IAE1BvJ,IAASiJ,IACXjJ,EAAO,KAGLwJ,IAAOP,IACTO,EAAKjF,EAAU,CAAC,IAAKiF,KAGvB,MAAMC,EACJD,IAAOP,EAAc,IAAMnE,EAAcP,EAAU,CAAC+E,EAAYtJ,KAElE,MAAO,CACLwJ,GAAIA,EACJD,QAASA,EACTvJ,KAAMA,EACNyJ,SAAUA,EACVlB,QAASA,EACTY,WACAO,YAAcP,GACZD,EAAkBX,EAASY,GAAU,EAAOE,EAAUC,GACxDP,YAAcY,GACZT,EAAkBS,OAAcpC,GAAW,EAAOiC,EAAIC,GACxDG,SAAU,KACRlL,GACE,EAED,EAEJ;;;;;;;;;;;AC5ZH,MAAMmL,EACJzK,UAAY,IAAIC,IAChByK,UAAW,EACXC,MAAQ,GACR7F,YAAY8F,EAAczB,GACxBI,KAAK1I,MAAQ+J,EACbrB,KAAKJ,QAAUA,CAChB,CACD0B,UAAYzK,IACVmJ,KAAKvJ,UAAUS,IAAIL,GACnB,MAAML,EAAQwJ,KAAKJ,SAAS2B,cAAc1K,EAAUmJ,MACpD,MAAO,KACLA,KAAKvJ,UAAUU,OAAON,GACtBL,KAAS,CACV,EAEHgL,SAAW1H,IACT,MAAMC,EAAWiG,KAAK1I,MACtB0I,KAAK1I,MAAQ0I,KAAKJ,SAAS6B,SAAWzB,KAAKJ,QAAQ6B,SAAS1H,EAAtBiG,CAAgClG,GAAWA,EAAQC,GACzFiG,KAAKoB,MAAMhK,MAAK,KACd4I,KAAKvJ,UAAUG,SAAQC,GAAYA,EAASmJ,KAAK1I,MAAOyC,KACxDiG,KAAKJ,SAASjJ,WAAWqJ,KAAK1I,MAAOyC,EAAS,IAEhDiG,MAAK0B,GAAQ,EAEfA,GAAS,KACH1B,KAAKmB,WACTnB,KAAKoB,MAAMxK,SAAQI,GAAMA,MACzBgJ,KAAKoB,MAAQ,GAAE,EAEjBO,MAAQ3K,IACNgJ,KAAKmB,UAAW,EAChBnK,IACAgJ,KAAKmB,UAAW,EAChBnB,MAAK0B,GAAQ,EClBjB,MAAME,EAAiB,CACrB,YACA,iBACA,oBAGK,MAAMC,EAcXC,gBAAkB,IAAIC,gBACtBC,sBAAwB,IAAItL,IAW5B6E,YACEuE,EACAO,EACAhK,GAMAyE,OAAOiF,OAAOC,KAAM,CAClBK,QACAP,SACAe,GAAIxK,EAAKwK,GACT5I,SAAU5B,EAAK4B,SACfyF,OAAQrH,EAAKqH,OACbuE,MAAO,IAAIf,EAAkD,CAC3DgB,UAAW,EACXC,YAAa,CAAE,EACfhK,OAAQ,CAAS,EACjBiK,OAAQ,WAIPpC,MAAKqC,KACRrC,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHF,OAAQ,aAGd,CAEAG,OAAS,KACPvC,KAAK8B,iBAAiBU,OAAO,EAG/BC,KAAOC,UAE2B,YAA5B1C,KAAKiC,MAAM3K,MAAM8K,cACbpC,KAAK2C,OACb,EAGFC,GAAY,GAEZD,MAAQD,UACN1C,KAAK6C,cAAgBC,QAAQC,UAAUC,MAAKN,UAC1C,MAAMO,EAAS,GAAKC,KAAKC,MAAQjK,KAAKO,SACtCuG,MAAK4C,EAAYK,EAEjB,MAAMG,EAAc,IACXH,IAAWjD,MAAK4C,EAAY5C,KAAK6C,mBAAgBjE,EAG1D,IAAIyE,EAEJrD,KAAKiC,MAAMN,OAAM,KAIiB,SAA5B3B,KAAKiC,MAAM3K,MAAM8K,QACnBpC,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHF,OAAQ,aAEZ,IAGF,MAAMkB,EAAoB,iBAIlBR,QAAQS,IACZ3B,EAAe5E,KAAI0F,UACjB,MAAMc,EAAYxD,KAAKK,MAAMT,QAAQxC,GAEjC4C,KAAK5C,IAAOqG,UACdzD,KAAK5C,SAAc4C,KAAKF,OAAOF,QAAQ8D,cAAeF,GACxD,IAGL,EAbyB,GAepBG,EAAcb,QAAQC,UAAUC,MAAK,KACzC,GAAIhD,KAAKK,MAAMT,QAAQgE,OACrB,OAAO5D,KAAKK,MAAMT,QAAQgE,OAAO,CAC/BlG,OAAQsC,KAAKtC,OACbvF,OAAQ6H,KAAKiC,MAAM3K,MAAMa,OACzB0L,OAAQ7D,KAAK8B,gBAAgB+B,QAGjC,IAGF,IAGE,SAFMP,QACAK,EACDN,EAAgBD,IAAgB,aAAaC,EAClDrD,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHwB,WAAOlF,EACPwD,OAAQ,UACRF,UAAWgB,KAAKC,SAWpB,CATE,MAAOY,GACP/D,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHwB,MAAOC,EACP3B,OAAQ,QACRF,UAAWgB,KAAKC,SAEpB,CAAU,eACDnD,KAAK6C,aACd,KAGK7C,KAAK6C,eAGdR,GAAc,OAEVrC,KAAKK,MAAMT,QAAQgE,SACnBhC,EAAeoC,MAAM/G,GAAM+C,KAAKK,MAAMT,QAAQ3C,IAAIwG,WAItDQ,iBAAoBC,KACblE,KAAKkE,aAAeA,IACvBlE,KAAKkE,YAAcA,EACrB,EAGFC,WAAa,KAEX,MAAMC,EACJpE,KAAKkE,aAAajC,MAAM3K,MAAMa,QAC9B6H,KAAKF,OAAOmC,MAAM3K,MAAM+M,eAAelM,OAEzC,IAME,IAAImM,GAJ2C,iBAAtCtE,KAAKK,MAAMT,QAAQ2E,eACtBvE,KAAKK,MAAMT,QAAQ2E,eAAeC,MAClCxE,KAAKK,MAAMT,QAAQ2E,kBAEIH,IAAiB,CAAA,EAE9CpE,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHH,YAAamC,EACbnM,OAAQ,IACHiM,KACAE,OAIP1C,EAAe5E,KAAI0F,UACjB,MAAMc,EAAYxD,KAAKK,MAAMT,QAAQxC,GAEX,mBAAf4C,KAAK5C,KACd4C,KAAK5C,GAAQoG,EACf,GAiBJ,CAfE,MAAOO,GACPU,QAAQX,MAAMC,GACd,MAAMD,EAAQ,IAAK5N,MAAc,8BAA+B,CAC9DwO,MAAOX,IAWT,OATAD,EAAMa,KAAO,6BAEb3E,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHF,OAAQ,QACR0B,MAAOA,KAKX,GCvOG,MAAMc,EAAqBC,EAAgBC,KAAKN,OAC1CO,EAAyBC,EAAoBF,KAAKG,WAExD,SAASJ,EAAgBK,GAC9B,OAAQC,IAC4B,MAA9BA,EAAU3L,UAAU,EAAG,KACzB2L,EAAYA,EAAU3L,UAAU,IAGlC,IAAI4L,EAAiC9F,EAAO6F,GAG5C,IAAK,IAAI1M,KAAO2M,EAAO,CACrB,MAAMtI,EAAQsI,EAAM3M,GACpB,GAAqB,iBAAVqE,EACT,IACEsI,EAAM3M,GAAOyM,EAAOpI,EAEpB,CADA,MAAOiH,GACP,CAGN,CAEA,OAAOqB,CAAK,CAEhB,CAEO,SAASJ,EAAoBC,GAClC,OAAQ9M,KACNA,EAAS,IAAKA,KAGZ2C,OAAOZ,KAAK/B,GAAQvB,SAAS6B,IAC3B,MAAM4M,EAAMlN,EAAOM,GACnB,QAAmB,IAAR4M,QAA+BzG,IAARyG,SACzBlN,EAAOM,QACT,GAAI4M,GAAsB,iBAARA,GAA4B,OAARA,EAC3C,IACElN,EAAOM,GAAOwM,EAAUI,EAExB,CADA,MAAOtB,GACP,CAEJ,IAIJ,MAAMoB,EAAYtG,EAAO1G,GAAkCuB,WAE3D,OAAOyL,EAAa,IAAGA,IAAc,EAAE,CAE3C,CCqKaG,MAAAA,EAA8C5C,OACzD5C,SACAyF,iBAEA,MAAM/K,EAAOsF,EAAO0F,UAAU,CAC5BhJ,GAAI,IACJrE,OAAS8E,IAAY,IACfA,GAAK,CAAA,EACTwI,OAAQ,CACNC,QAASH,EAAW1E,QAKpB8E,QAAYhD,MAAMnI,EAAKpB,KAAM,CACjCwM,OAAQ,MACR/B,OAAQ0B,EAAWzD,gBAAgB+B,SAGrC,GAAI8B,EAAIE,GACN,OAAOF,EAAIG,OAGb,MAAM,IAAI5P,MAAM,6BAA6B,EA45B/C,MAAM6P,EAA6B,oBAAX/N,SAA2BA,OAAOgO,SAASC,cAEnE,SAASC,IACP,MAAO,CACL9D,OAAQ,OACRiC,eAAgB,KAChB/N,gBAAiB,KACjB6P,eAAgB,GAChBC,YAAalD,KAAKC,MAgBtB,mCAj7BO,MAgBLkD,GAUAC,iBAAmBpD,KAAKC,MACxBoD,kBAAoB,OAEpBhL,YAAYqE,GACVI,KAAKJ,QAAU,CACb4G,oBAAqB,GACrBC,aAAS7H,KACNgB,EACH8G,gBAAiB9G,GAAS8G,iBAAmB3B,EAC7C4B,YAAa/G,GAAS+G,aAAe/B,EACrCgC,kBAAmBhH,GAASgH,mBAAqBtB,GAGnDtF,KAAKiC,MAAQ,IAAIf,EAAMgF,KACvBlG,KAAK1D,SAAW,GAEhB0D,KAAK6G,OAAOjH,GAGZI,KAAKJ,QAAQkH,SAAS9G,KACxB,CAEA+G,MAAQ,KACN/G,KAAKiC,MAAMT,UAAUc,GAAMxH,OAAOiF,OAAOuC,EAAG4D,MAAyB,EAGvEc,MAAQ,KAEN,IAAKjB,EAAU,CAER/F,KAAKiC,MAAM3K,MAAM6O,eAAenN,QACnCgH,KAAKyC,OAGP,MAAMwE,EAAwB,mBACxBC,EAAa,QAWnB,OANIlP,OAAOO,mBAETP,OAAOO,iBAAiB0O,EAAuBjH,MAAKmH,GAAU,GAC9DnP,OAAOO,iBAAiB2O,EAAYlH,MAAKmH,GAAU,IAG9C,KACDnP,OAAOQ,sBAGTR,OAAOQ,oBAAoByO,EAAuBjH,MAAKmH,GACvDnP,OAAOQ,oBAAoB0O,EAAYlH,MAAKmH,GAC9C,CAEJ,CAEA,MAAO,MAAQ,EAGjBN,OAKExQ,IAEAyE,OAAOiF,OAAOC,KAAKJ,QAASvJ,KAGzB2J,KAAK1H,SACL0H,KAAKJ,QAAQtH,SAAW0H,KAAKJ,QAAQtH,UAAY0H,KAAK1H,WAEnD0H,MAAKqG,GACPrG,MAAKqG,IAGPrG,KAAK1H,QACH0H,KAAKJ,QAAQtH,UACZyN,EAAWnN,IAAwBd,KAEtCkI,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACH+B,eAAgBrE,MAAK3H,IACrB/B,gBAAiBgM,EAAE+B,mBAGrBrE,MAAKqG,EAAgBrG,KAAK1H,QAAQvB,QAAO,KACvCiJ,KAAKyC,KAAKzC,MAAK3H,EAAe2H,KAAKiC,MAAM3K,MAAM+M,gBAAgB,KAInE,MAAM/H,SAAEA,EAAQqD,YAAEA,GAAgBK,KAAKJ,QASvC,OAPAI,KAAK1D,SAAY,IAAGF,EAASE,GAAY,KAAO,KAE5CqD,IACFK,KAAKoH,WAAa,GAClBpH,KAAKqH,UAAYrH,MAAKsH,EAAgB3H,IAGjCK,IAAI,EAGbwF,UAAanP,IACX,MAAMmE,EAAOwF,MAAKuH,EAAelR,GAE3BmR,EAAUxH,KAAKyH,YAAYjN,EAAKvC,UAEhCyP,EAAqBF,EACxBxK,KAAK2K,GAAUA,EAAMtH,MAAMT,QAAQgI,kBAAoB,KACvDC,OACA9L,OAAOC,SAEJ8L,EAAsBN,EACzBxK,KAAK2K,GAAUA,EAAMtH,MAAMT,QAAQmI,mBAAqB,KACxDF,OACA9L,OAAOC,SAEV,OAAOgE,MAAKuH,EAAe,IACtBlR,EACHqR,qBACAI,uBACA,EAGJE,cAAgB,KACb,IACIhI,KAAKiC,MAAM3K,MAAM6O,kBAChBnG,KAAKiC,MAAM3K,MAAM2Q,gBAAkB,IACvCrR,SAAS+Q,IACTA,EAAMpF,QAAQ,GACd,EAGJE,KAAOC,UACL,IAAIS,EAAMD,KAAKC,MACf,MAAM+E,EAAY/E,EAMlB,IAAIqE,EALJxH,KAAKsG,iBAAmB4B,EAGxBlI,KAAKgI,gBAILhI,KAAKiC,MAAMN,OAAM,KACXnH,GAEFwF,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACH+B,eAAgB7J,MAKpBgN,EAAUxH,KAAKyH,YAAYzH,KAAKiC,MAAM3K,MAAM+M,eAAepM,SAAU,CACnEkQ,mBAAmB,IAGrBnI,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHF,OAAQ,UACR6F,eAAgBT,EAChBY,gBAAiBpI,KAAKiC,MAAM3K,MAAM+M,kBACjC,IAIL,UACQrE,KAAKqI,YAAYb,EAOzB,CANE,MAAOzD,GACPU,QAAQ6D,KAAKvE,GACbhO,GACE,EAGJ,CAEA,GAAIiK,KAAKsG,mBAAqB4B,EAE5B,OAAOlI,KAAKuI,kBAGd,MAAMC,EAAkBxI,KAAKiC,MAAM3K,MAAM6O,eAEnCsC,EAAwB,GAC5BC,EAAwB,GAE1BF,EAAgB5R,SAASqG,IACnBuK,EAAQmB,MAAMC,GAAOA,EAAG/H,KAAO5D,EAAE4D,KACnC6H,EAAQtR,KAAK6F,GAEbwL,EAAQrR,KAAK6F,EACf,IAGF,MAAM4L,EAAWrB,EAAQzL,QAAQkB,IACvBuL,EAAgBG,MAAMC,GAAOA,EAAG/H,KAAO5D,EAAE4D,OAGnDsC,EAAMD,KAAKC,MAEXsF,EAAQ7R,SAASqG,IACfA,EAAE6L,WAAW,CACXpL,OAAQT,EAAES,OACVvF,OAAQ8E,EAAEgF,MAAM3K,MAAM6K,cAIK,UAAzBlF,EAAEgF,MAAM3K,MAAM8K,QAChBpC,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHF,OAAQ,OACR0B,WAAOlF,KAEX,IAGF8J,EAAQ9R,SAASqG,IACfA,EAAEoD,MAAMT,QAAQmJ,eAAe,CAC7BrL,OAAQT,EAAES,OACVvF,OAAQ8E,EAAEgF,MAAM3K,MAAM6K,aACtB,IAGJ0G,EAASjS,SAASqG,IAChBA,EAAE6L,SAAW7L,EAAEoD,MAAMT,QAAQoJ,WAAW,CACtCtL,OAAQT,EAAES,OACVvF,OAAQ8E,EAAEgF,MAAM3K,MAAMa,QACtB,IAIJ6H,KAAKiC,MAAMT,UAAUc,IAAO,IACvBA,EACHF,OAAQ,OACR9L,gBAAiB0J,KAAKiC,MAAM3K,MAAM+M,eAClC8B,eAAgBqB,EAChBY,qBAAiBxJ,EACjBqJ,oBAAgBrJ,MAGlBoB,KAAKJ,QAAQqJ,kBAEbjJ,KAAKuG,mBAAmB,EAG1B2C,SACErI,IAEA,MAAMR,EAAQL,KAAKoH,WAAWvG,GAI9B,OAFA9K,EAAUsK,GAEHA,CAAK,EAGd8I,UAAYzG,MACV0G,EAAiCpJ,KAAKiC,MAAM3K,MAAM+M,kBAElD,MAAM7J,EAAOwF,KAAKwF,UAAU4D,GACtB5B,EAAUxH,KAAKyH,YAAYjN,EAAKvC,SAAU,CAC9CkQ,mBAAmB,IAGrB,aADMnI,KAAKqI,YAAYb,GAChBA,CAAO,EAGhB6B,aAAe3G,MACb0G,EAAiCpJ,KAAKiC,MAAM3K,MAAM+M,kBAElD,MAAM7J,EAAOwF,KAAKwF,UAAU4D,GACtB5B,EAAUxH,KAAKyH,YAAYjN,EAAKvC,SAAU,CAC9CkQ,mBAAmB,IAMrB,aAHMnI,KAAKqI,YAAYb,EAAS,CAC9B/D,SAAS,IAEJ+D,CAAO,EAGhBC,YAAc,CAACxP,EAAkB5B,KAC/B,MAAMmR,EAAwB,GAE9B,IAAKxH,KAAKqH,UACR,OAAOG,EAGT,MAAM8B,EAAkB,IACnBtJ,KAAKiC,MAAM3K,MAAM6O,kBAChBnG,KAAKiC,MAAM3K,MAAM2Q,gBAAkB,IAGnCsB,EAAU7G,UAEd,IAAIhF,EADgB/D,EAAK6N,IACC9J,QAAU,GAEpC,MAAM8L,EAAiBxJ,KAAKJ,QAAQ6J,eAAeC,IAAWA,EAE9D,IAAIC,EAAuB,GAE3B,MAAMC,EAAoB,CAACC,EAAuBH,KAChDA,EAAO1F,MAAM3D,IACX,IAAKA,EAAMhJ,MAAQgJ,EAAMH,aAAalH,OACpC,OAAO4Q,EAAkB,IAAID,EAAatJ,GAAQA,EAAMH,aAG1D,MAAMvB,IAA0B,MAAf0B,EAAMhJ,OAAgBgJ,EAAMH,aAAalH,QAEpD8Q,EAAcjM,EAAcmC,KAAK1D,SAAUrE,EAAU,CACzDuE,GAAI6D,EAAMS,SACVnC,QACAF,cACE4B,EAAMT,QAAQnB,eAAiBuB,KAAKJ,QAAQnB,gBAGhD,GAAIqL,EAAa,CACf,IAAIC,EAEJ,IACEA,EACE1J,EAAMT,QAAQoK,cAAcF,IAAiBA,CAKjD,CAJE,MAAO/F,GACP,GAAI1N,GAAM8R,kBACR,MAAMpE,CAEV,CAEArG,EAAS,IACJA,KACAqM,EAEP,CAMA,OAJMD,IACJH,EAAc,IAAIE,EAAcxJ,MAGzBsJ,EAAY3Q,MAAM,MAGpB2Q,EAAY3Q,QAKvB,GAFA4Q,EAAkB,GAAIJ,IAEjBG,EAAY3Q,OACf,OAGF2Q,EAAY/S,SAASqT,IACnB,MAAMC,EAAmBzM,EAAgBwM,EAAW5S,KAAMqG,GACpDgI,EAAUjI,EAAgBwM,EAAWpJ,GAAInD,GAAQ,GAEjDiK,EACJ2B,EAAgBX,MAAM1L,GAAMA,EAAE4D,KAAO6E,KAErC,IAAI7D,EAAW7B,KAAMiK,EAAY,CAC/BpJ,GAAI6E,EACJhI,SACAzF,SAAU2D,EAAU,CAACoE,KAAK1D,SAAU4N,MAGxC1C,EAAQpQ,KAAKuQ,EAAM,IAGrB,MAAMsC,EAAatQ,EAAKgQ,GAEpBM,EAAW/J,aAAalH,QAC1BuQ,EAAQU,EAAW/J,YACrB,EAOF,OAJAqJ,EAAQ,CAACvJ,KAAKqH,YAwiBlB,SAAqBG,GACnBA,EAAQ5Q,SAAQ,CAAC+Q,EAAOhQ,KACtB,MAAMsC,EAASuN,EAAQ7P,EAAQ,GAE3BsC,GACF0N,EAAM1D,iBAAiBhK,EACzB,GAEJ,CA9iBIkQ,CAAY3C,GAELA,CAAO,EAGhBa,YAAc3F,MACZ0H,EACAC,KAGAD,EAAgBxT,SAAQ8L,UAEtBiF,EAAMxD,YAAY,UAIdrB,QAAQS,IACZ6G,EAAgBpN,KAAI0F,UAClB,UACQiF,EAAMtH,MAAMT,QAAQ0K,aAAa,CACrCxK,OAAQE,KACR2H,UAQJ,CANE,MAAO5D,GAKP,MAJKsG,GAAY5G,SACfkE,EAAMtH,MAAMT,QAAQ2K,cAAcxG,GAG9BA,CACR,MAIJ,MAAMyG,EAAgBJ,EAAgBpN,KAAI0F,MAAOiF,EAAOhQ,KACtD,MAAM8S,EAAYL,EAAyB,GACrCjS,EAASwP,EAAM1F,MAAM3K,MAAMa,OAE7BA,EAAOsN,QAAQC,SAAWvN,EAAOsN,OAAOC,UAAYiC,EAAM9G,KAI9D8G,EAAMlF,OAE2B,YAA7BkF,EAAM1F,MAAM3K,MAAM8K,QAAwBuF,EAAM9E,qBAE5C8E,EAAM9E,cAGV4H,SACIA,EAAU5H,cAClB,UAGIC,QAAQS,IAAIiH,EAAc,EAGlCE,OAAS,KACP1K,KAAK2K,SAAS,CACZC,aAAa,EACbpT,SAAS,EACTW,QAAQ,GACD,EAGXkE,YAAc,CAAC6B,EAAc7G,IACpBgF,EAAY2D,KAAK1D,SAAW4B,EAAMpC,EAAUzE,IAGrDsT,SAAWjI,OAITxE,OACA1B,KAAK,IACLrE,SACAD,OACAV,UACAkG,aAOA,MAAMhE,EAAWmR,OAAOrO,GAClBsO,OAA6B,IAAT5M,EAAuBA,EAAO2M,OAAO3M,GAC/D,IAAI6M,EAEJ,IACE,IAAIC,IAAK,GAAEtR,KACXqR,GAAa,CACF,CAAX,MAAOE,GAAI,CAOb,OALAlV,GACGgV,GAII/K,MAAKkL,EAAgB,CAC1BhN,KAAM4M,EACNtO,GAAI9C,EACJvB,SACAD,OACAV,UACAkG,UACA,EAGJyN,WAAa,CAIXrU,EACAT,KAOAS,EAAW,IACNA,EACH0F,GAAI1F,EAAS0F,GACTwD,KAAK3D,YAAYvF,EAASoH,MAAQ,GAAIpH,EAAS0F,SAC/CoC,GAGN,MAAMpE,EAAOwF,KAAKwF,UAAU1O,GAE5B,OAAIT,GAAM+U,UACHpL,KAAKiC,MAAM3K,MAAM8Q,iBAIfvK,EACLmC,KAAK1D,SACL0D,KAAKiC,MAAM3K,MAAM8Q,gBAAiBnQ,SAClC,IACK5B,EACHmG,GAAIhC,EAAKvC,WAKR4F,EACLmC,KAAK1D,SACL0D,KAAKiC,MAAM3K,MAAMhB,gBAAgB2B,SACjC,IACK5B,EACHmG,GAAIhC,EAAKvC,UAEZ,EAGHoT,UAAY,EAIVnN,OACA1B,KAAK,IACLrE,SACAuF,SACAxF,OACAoT,SACA9T,UACA+T,gBACA9H,UACA+H,cAAeC,EACfC,gBAAiBC,EACjBC,aAAcC,EACdC,eAQA,IAEE,OADA,IAAId,IAAK,GAAExO,KACJ,CACLY,KAAM,WACNhE,KAAMoD,EAEG,CAAX,MAAOyO,GAAI,CAEb,MAAMc,EAAW,CACf7N,OACA1B,KACArE,SACAuF,SACAxF,OACAV,WAGIgD,EAAOwF,KAAKwF,UAAUuG,GAE5BtI,EAAUA,GAAWzD,KAAKJ,QAAQoM,eAClC,MAAMJ,EACJC,GAAoB7L,KAAKJ,QAAQ4G,qBAAuB,EAGpDyF,EACJjM,KAAKiC,MAAM3K,MAAMhB,gBAAgB2B,WAAauC,EAAKvC,SAC/CiU,EACJlM,KAAKiC,MAAM3K,MAAMhB,gBAAgB2B,SAASoF,MAAM,KAE5C8O,EADgB3R,EAAKvC,SAASoF,MAAM,KACH+O,OACrC,CAACnP,EAAG9B,IAAM8B,IAAMiP,EAAiB/Q,KAE7BkR,EAAcrM,KAAKiC,MAAM3K,MAAMhB,gBAAgB4B,OAASsC,EAAKtC,KA6DnE,MAAO,CACLkF,KAAM,WACN5C,OACA8R,YAvCmBrB,IACfxH,GACFzD,KAAKqJ,aAAa0C,GAAUQ,OAAOxI,IACjCU,QAAQ6D,KAAKvE,GACbU,QAAQ6D,KAAK,6BAA6B,GAE9C,EAkCAkE,YAxDmBvB,IAEhBa,GAqUT,SAAqBb,GACnB,SAAUA,EAAEwB,SAAWxB,EAAEyB,QAAUzB,EAAE0B,SAAW1B,EAAE2B,SACpD,CAtUSC,CAAY5B,IACZA,EAAE6B,kBACDxB,GAAqB,UAAXA,GACC,IAAbL,EAAE8B,SAEF9B,EAAE+B,iBAGFhN,MAAKkL,EAAgBa,GACvB,EA6CAkB,YAhCmBhC,IACnB,MAAMK,EAAUL,EAAEK,QAAU,GAE5B,GAAI7H,EAAS,CACX,GAAI6H,EAAO4B,eACT,OAGF5B,EAAO4B,eAAiBC,YAAW,KACjC7B,EAAO4B,eAAiB,KACxBlN,KAAKqJ,aAAa0C,GAAUQ,OAAOxI,IACjCU,QAAQ6D,KAAKvE,GACbU,QAAQ6D,KAAK,6BAA6B,GAC1C,GACDsD,EACL,GAkBAwB,YAfmBnC,IACnB,MAAMK,EAAUL,EAAEK,QAAU,GAExBA,EAAO4B,iBACTG,aAAa/B,EAAO4B,gBACpB5B,EAAO4B,eAAiB,KAC1B,EAUAI,UAlEe/B,GAAegC,MAAQtB,EAAcE,MACrCZ,GAAeiC,aAAcnB,GAkE5CP,WACD,EAGH2B,UAAY,KACH,CACLnW,MAAO,IACF0C,EAAKgG,KAAKiC,MAAM3K,MAAO,CACxB,iBACA,kBACA,SACA,gBAEF6O,eAAgBnG,KAAKiC,MAAM3K,MAAM6O,eAAenJ,KAAK2K,IAAW,CAC9D9G,GAAI8G,EAAM9G,GACVvJ,MAAO,IACF0C,EAAK2N,EAAM1F,MAAM3K,MAAO,CAAC,iBAIlCmP,QAASzG,KAAKJ,QAAQ6G,UAI1BiH,QAAWC,IACT3N,KAAKiC,MAAMT,UAAUc,IACnBtC,KAAKJ,QAAQ6G,QAAUkH,EAAiBlH,QAGxC,MAAMN,EAAiBnG,KAAKyH,YAC1BkG,EAAiBrW,MAAM+M,eAAepM,SACtC,CACEkQ,mBAAmB,IAkBvB,OAdAhC,EAAevP,SAAQ,CAAC+Q,EAAOhQ,KAC7B,MAAMiW,EAAkBD,EAAiBrW,MAAM6O,eAAexO,GAC9D5B,EACE6X,GAAmBA,EAAgB/M,KAAO8G,EAAM9G,IAGlD8G,EAAM1F,MAAMT,UAAUc,IAAO,IACxBA,KACAsL,EAAgBtW,SAClB,IAGL6O,EAAevP,SAAS+Q,GAAUA,EAAMxD,eAEjC,IACF7B,KACAqL,EAAiBrW,MACpB6O,iBACD,GACD,EAGJmB,GAAmBuG,IACjB,MAAMC,EAAgB,CACpBC,EACA9T,IAEO8T,EAAa/Q,KAAI,CAAC2C,EAAaxE,KACpC,MAAM6S,EAAerO,EAAYC,QAC3BS,EAAQ,IAAIX,EAAMC,EAAaqO,EAAc7S,EAAGlB,EAAQ+F,MAG9D,GAFuBA,KAAKoH,WAAmB/G,EAAMQ,IAUnD,MAAM,IAAI3K,MAGV8J,KAAKoH,WAAmB/G,EAAMQ,IAAMR,EAEtC,MAAMG,EAAWb,EAAYa,SAM7B,OAJAH,EAAMH,YAAcM,EAASxH,OACzB8U,EAActN,EAAUH,QACxBzB,EAEGyB,CAAK,IAMhB,OAFeyN,EAAc,CAACD,IAEhB,EAAE,EAGlBxV,GAAkB4V,IAChB,IAAIhW,SAAEA,EAAQE,OAAEA,EAAMD,KAAEA,EAAIZ,MAAEA,GAAU0I,KAAK1H,QAAQxB,SAErD,MAAMoX,EAAelO,KAAKJ,QAAQ+G,YAAYxO,GAE9C,MAAO,CACLF,SAAUA,EACVkN,UAAWhN,EACXA,OAAQkC,EAAiB4T,GAAkB9V,OAAQ+V,GACnDhW,KAAMA,EAAKmF,MAAM,KAAK8Q,UAAU,IAAM,GACtC/U,KAAO,GAAEnB,IAAWE,IAASD,IAC7BZ,MAAOA,EACPmB,IAAKnB,GAAOmB,KAAO,WACpB,EAGH0O,GAAW,KACTnH,KAAKyC,MAAM,EAGb8E,GAAiB,CAAC6G,EAAyB,MACzC,MAAMC,EAAeD,EAAKxD,YACtB5K,KAAKiC,MAAM3K,MAAM+M,eAAepM,SAChCmW,EAAKlQ,MAAQ8B,KAAKiC,MAAM3K,MAAM+M,eAAepM,SAEjD,IAAIA,EAAWoE,EACb2D,KAAK1D,UAAY,IACjB+R,EACC,GAAED,EAAK5R,IAAM,OAGhB,MAAM8R,EAActO,KAAKyH,YACvBzH,KAAKiC,MAAM3K,MAAM+M,eAAepM,SAChC,CACEkQ,mBAAmB,IAIjBoG,EAAYvO,KAAKyH,YAAYxP,GAE7BuW,EAAa,IAAK7U,EAAK2U,IAAc5Q,QAE3C,IAAI+Q,GACwB,KAAzBL,EAAK1Q,SAAU,GACZ8Q,EACA3U,EAAiBuU,EAAK1Q,OAAS8Q,GAEjCC,GACFF,EACGvR,KAAKC,GAAMA,EAAEoD,MAAMT,QAAQ8O,kBAC3B3S,OAAOC,SACPpF,SAAS+X,IACR7T,OAAOiF,OAAO,CAAE,EAAE0O,EAAaE,EAAIF,GAAa,IAItDxW,EAAWwF,EAAgBxF,EAAUwW,GAAc,CAAE,GAGrD,MAAMG,EAAoBR,EAAK1G,oBAAoB1O,OAC/CoV,EAAK1G,oBAAoBvN,QACvB,CAACG,EAAME,IAASA,EAAKF,IACrB0F,KAAKiC,MAAM3K,MAAM+M,eAAelM,QAElC6H,KAAKiC,MAAM3K,MAAM+M,eAAelM,OAG9B0W,GACY,IAAhBT,EAAKjW,OACDyW,EACAR,EAAKjW,OACL0B,EAAiBuU,EAAKjW,OAAQyW,IAAsB,CAAE,EACtDR,EAAK1G,oBAAoB1O,OACzB4V,EACA,GAGAE,EAAqBV,EAAKtG,qBAAqB9O,OACjDoV,EAAKtG,oBAAoB3N,QAAO,CAACG,EAAME,IAASA,EAAKF,IAAOuU,GAC5DA,EAEE1W,EAASkC,EACb2F,KAAKiC,MAAM3K,MAAM+M,eAAelM,OAChC2W,GAGI3J,EAAYnF,KAAKJ,QAAQ8G,gBAAgBvO,GAC/C,IAAID,GACY,IAAdkW,EAAKlW,KACD8H,KAAKiC,MAAM3K,MAAM+M,eAAenM,KAChC2B,EAAiBuU,EAAKlW,KAAO8H,KAAKiC,MAAM3K,MAAM+M,eAAenM,MAGnE,OAFAA,EAAOA,EAAQ,IAAGA,IAAS,GAEpB,CACLD,WACAE,SACAgN,YACA7N,MAAO0I,KAAKiC,MAAM3K,MAAM+M,eAAe/M,MACvCY,OACAkB,KAAO,GAAEnB,IAAWkN,IAAYjN,IAChCO,IAAK2V,EAAK3V,IACX,EAGHyS,GAAmBpU,IACjB,MAAM0D,EAAOwF,KAAKwF,UAAU1O,GACtB+J,EAAK,GAAKqC,KAAKC,MAAQjK,KAAKO,SAE9BuG,KAAK+O,iBAAiB1B,aAAarN,KAAK+O,iBAE5C,IAAIC,EAAiC,UAEhClY,EAASU,UACZwX,EAAa,QAGGhP,KAAKiC,MAAM3K,MAAM+M,eAAejL,OAASoB,EAAKpB,OAE9CoB,EAAK/B,MACrBuW,EAAa,WAGf,MAAM5V,EAAQ,GAAEoB,EAAKvC,WAAWuC,EAAK2K,YACnC3K,EAAKtC,KAAQ,IAAGsC,EAAKtC,OAAS,KAUhC,OAPA8H,KAAK1H,QAAuB,SAAf0W,EAAwB,OAAS,WAAW5V,EAAM,CAC7DyH,QACGrG,EAAKlD,QAKF0I,KAAKuI,kBAAoB,IAAIzF,SAASC,IAC5C,MAAMkM,EAA4BjP,KAAKuG,kBAEvCvG,KAAKuG,kBAAoB,KACvB0I,IACAlM,GAAS,CACV,GACD,8DTzgCC,WACL,OAAOjL,EAAqB,CAC1BC,QAAS,IAAMC,OAAOlB,SAASoB,KAAKsB,UAAU,GAC9CpB,WAAaf,GAAU,IAAGA,KAE9B,6cClEO,SAAiB6X,EAAWjZ,GACjC,GAAIiZ,EAAM,CACe,oBAAZzK,SAAyBA,QAAQ6D,KAAKrS,GAEjD,IACE,MAAM,IAAIC,MAAMD,EACT,CAAP,MAAO,CACX,CAEA,OAAO,CACT"}