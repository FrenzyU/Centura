{"version":3,"file":"routeMatch.js","sources":["../../src/routeMatch.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\n//\nimport { GetFrameworkGeneric } from './frameworks'\nimport { Route } from './route'\nimport {\n  AnyAllRouteInfo,\n  AnyRouteInfo,\n  DefaultAllRouteInfo,\n  RouteInfo,\n} from './routeInfo'\nimport { AnyRouter, Router } from './router'\nimport { Expand } from './utils'\n\nexport interface RouteMatchStore<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n> {\n  routeSearch: TRouteInfo['searchSchema']\n  search: Expand<\n    TAllRouteInfo['fullSearchSchema'] & TRouteInfo['fullSearchSchema']\n  >\n  status: 'idle' | 'pending' | 'success' | 'error'\n  error?: unknown\n  updatedAt: number\n}\n\nconst componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport class RouteMatch<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n> {\n  route!: Route<TAllRouteInfo, TRouteInfo>\n  router!: Router<TAllRouteInfo['routeConfig'], TAllRouteInfo>\n  store!: Store<RouteMatchStore<TAllRouteInfo, TRouteInfo>>\n  id!: string\n  pathname!: string\n  params!: TRouteInfo['allParams']\n\n  component: GetFrameworkGeneric<'Component'>\n  errorComponent: GetFrameworkGeneric<'ErrorComponent'>\n  pendingComponent: GetFrameworkGeneric<'Component'>\n  abortController = new AbortController()\n  onLoaderDataListeners = new Set<() => void>()\n  parentMatch?: RouteMatch\n\n  __loadPromise?: Promise<void>\n  __onExit?:\n    | void\n    | ((matchContext: {\n        params: TRouteInfo['allParams']\n        search: TRouteInfo['fullSearchSchema']\n      }) => void)\n\n  constructor(\n    router: AnyRouter,\n    route: Route<TAllRouteInfo, TRouteInfo>,\n    opts: {\n      id: string\n      params: TRouteInfo['allParams']\n      pathname: string\n    },\n  ) {\n    Object.assign(this, {\n      route,\n      router,\n      id: opts.id,\n      pathname: opts.pathname,\n      params: opts.params,\n      store: new Store<RouteMatchStore<TAllRouteInfo, TRouteInfo>>({\n        updatedAt: 0,\n        routeSearch: {},\n        search: {} as any,\n        status: 'idle',\n      }),\n    })\n\n    if (!this.#hasLoaders()) {\n      this.store.setState((s) => ({\n        ...s,\n        status: 'success',\n      }))\n    }\n  }\n\n  cancel = () => {\n    this.abortController?.abort()\n  }\n\n  load = async (): Promise<void> => {\n    // If the match is invalid, errored or idle, trigger it to load\n    if (this.store.state.status !== 'pending') {\n      await this.fetch()\n    }\n  }\n\n  #latestId = ''\n\n  fetch = async (): Promise<void> => {\n    this.__loadPromise = Promise.resolve().then(async () => {\n      const loadId = '' + Date.now() + Math.random()\n      this.#latestId = loadId\n\n      const checkLatest = () => {\n        return loadId !== this.#latestId ? this.__loadPromise : undefined\n      }\n\n      let latestPromise\n\n      this.store.batch(() => {\n        // If the match was in an error state, set it\n        // to a loading state again. Otherwise, keep it\n        // as loading or resolved\n        if (this.store.state.status === 'idle') {\n          this.store.setState((s) => ({\n            ...s,\n            status: 'pending',\n          }))\n        }\n      })\n\n      const componentsPromise = (async () => {\n        // then run all component and data loaders in parallel\n        // For each component type, potentially load it asynchronously\n\n        await Promise.all(\n          componentTypes.map(async (type) => {\n            const component = this.route.options[type]\n\n            if (this[type]?.preload) {\n              this[type] = await this.router.options.loadComponent!(component)\n            }\n          }),\n        )\n      })()\n\n      const dataPromise = Promise.resolve().then(() => {\n        if (this.route.options.onLoad) {\n          return this.route.options.onLoad({\n            params: this.params,\n            search: this.store.state.search,\n            signal: this.abortController.signal,\n          })\n        }\n        return\n      })\n\n      try {\n        await componentsPromise\n        await dataPromise\n        if ((latestPromise = checkLatest())) return await latestPromise\n        this.store.setState((s) => ({\n          ...s,\n          error: undefined,\n          status: 'success',\n          updatedAt: Date.now(),\n        }))\n      } catch (err) {\n        this.store.setState((s) => ({\n          ...s,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now(),\n        }))\n      } finally {\n        delete this.__loadPromise\n      }\n    })\n\n    return this.__loadPromise\n  }\n\n  #hasLoaders = () => {\n    return !!(\n      this.route.options.onLoad ||\n      componentTypes.some((d) => this.route.options[d]?.preload)\n    )\n  }\n\n  __setParentMatch = (parentMatch?: RouteMatch) => {\n    if (!this.parentMatch && parentMatch) {\n      this.parentMatch = parentMatch\n    }\n  }\n\n  __validate = () => {\n    // Validate the search params and stabilize them\n    const parentSearch =\n      this.parentMatch?.store.state.search ??\n      this.router.store.state.latestLocation.search\n\n    try {\n      const validator =\n        typeof this.route.options.validateSearch === 'object'\n          ? this.route.options.validateSearch.parse\n          : this.route.options.validateSearch\n\n      let nextSearch = validator?.(parentSearch) ?? {}\n\n      this.store.setState((s) => ({\n        ...s,\n        routeSearch: nextSearch,\n        search: {\n          ...parentSearch,\n          ...nextSearch,\n        } as any,\n      }))\n\n      componentTypes.map(async (type) => {\n        const component = this.route.options[type]\n\n        if (typeof this[type] !== 'function') {\n          this[type] = component\n        }\n      })\n    } catch (err: any) {\n      console.error(err)\n      const error = new (Error as any)('Invalid search params found', {\n        cause: err,\n      })\n      error.code = 'INVALID_SEARCH_PARAMS'\n\n      this.store.setState((s) => ({\n        ...s,\n        status: 'error',\n        error: error,\n      }))\n\n      // Do not proceed with loading the route\n      return\n    }\n  }\n}\n"],"names":["componentTypes","RouteMatch","abortController","AbortController","onLoaderDataListeners","Set","constructor","router","route","opts","Object","assign","id","pathname","params","store","Store","updatedAt","routeSearch","search","status","setState","s","cancel","abort","load","state","fetch","__loadPromise","Promise","resolve","then","loadId","Date","now","Math","random","checkLatest","undefined","latestPromise","batch","componentsPromise","all","map","type","component","options","preload","loadComponent","dataPromise","onLoad","signal","error","err","some","d","__setParentMatch","parentMatch","__validate","parentSearch","latestLocation","validator","validateSearch","parse","nextSearch","console","Error","cause","code"],"mappings":"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"}