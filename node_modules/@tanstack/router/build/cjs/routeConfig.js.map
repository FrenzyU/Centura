{"version":3,"file":"routeConfig.js","sources":["../../src/routeConfig.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport { GetFrameworkGeneric } from './frameworks'\nimport { ParsePathParams } from './link'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { RouteInfo } from './routeInfo'\nimport { RouteMatch } from './routeMatch'\nimport { AnyRouter, RegisteredRouter, Router } from './router'\nimport { Expand, IsAny, NoInfer, PickUnsafe } from './utils'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\n\nexport type AnyLoaderData = {}\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport interface RouteMeta {}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> = (\n  loaderContext: LoaderContext<TFullSearchSchema, TAllParams>,\n) => Promise<any> | void\n\nexport interface LoaderContext<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> {\n  params: TAllParams\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  // parentLoaderPromise?: Promise<TParentRouteLoaderData>\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, RouteInfo<string, TPath>>,\n) => void\n\nexport type RouteOptions<\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams = {},\n> = (\n  | {\n      // The path to match (relative to the nearest parent `Route` component or root basepath)\n      path: TPath\n    }\n  | {\n      id: TRouteId\n    }\n) & {\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: GetFrameworkGeneric<'Component'> // , NoInfer<TParentAllLoaderData>>\n  // The content to be rendered when the route encounters an error\n  errorComponent?: GetFrameworkGeneric<'ErrorComponent'> // , NoInfer<TParentAllLoaderData>>\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: GetFrameworkGeneric<'Component'> //, NoInfer<TParentAllLoaderData>>\n\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: (opts: {\n    router: AnyRouter\n    match: RouteMatch\n  }) => Promise<void> | void\n\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  onLoad?: OnLoadFn<TFullSearchSchema, TAllParams>\n\n  // This function will be called if the route's loader throws an error **during an attempted navigation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  onLoadError?: (err: any) => void\n  // This function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onLoaded?: (matchContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) =>\n    | void\n    | undefined\n    | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) => void\n  // An object of whatever you want! This object is accessible anywhere matches are.\n  meta?: RouteMeta // TODO: Make this nested and mergeable\n} & (\n    | {\n        parseParams?: never\n        stringifyParams?: never\n      }\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams\n        stringifyParams: (\n          params: TParams,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? {}\n    : 'Cannot redefined path params in child routes!')\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport interface RouteConfig<\n  TId extends string = string,\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TFullPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TParentParams extends AnyPathParams = {},\n  TParams extends AnyPathParams = {},\n  TAllParams extends AnyPathParams = {},\n  TKnownChildren = unknown,\n> {\n  id: TId\n  routeId: TRouteId\n  path: NoInfer<TPath>\n  fullPath: TFullPath\n  options: RouteOptions<\n    TRouteId,\n    TPath,\n    TParentSearchSchema,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParentParams,\n    TParams,\n    TAllParams\n  >\n  children?: TKnownChildren\n  addChildren: IsAny<\n    TId,\n    any,\n    <TNewChildren extends any>(\n      children: TNewChildren extends AnyRouteConfig[]\n        ? TNewChildren\n        : { error: 'Invalid route detected'; route: TNewChildren },\n    ) => RouteConfig<\n      TId,\n      TRouteId,\n      TPath,\n      TFullPath,\n      TParentSearchSchema,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentParams,\n      TParams,\n      TAllParams,\n      TNewChildren\n    >\n  >\n  createRoute: CreateRouteConfigFn<\n    false,\n    TId,\n    TFullPath,\n    TFullSearchSchema,\n    TAllParams\n  >\n  generate: GenerateFn<TRouteId, TPath, TParentSearchSchema, TParentParams>\n}\n\ntype GenerateFn<\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TParentSearchSchema extends {} = {},\n  TParentParams extends AnyPathParams = {},\n> = <\n  TSearchSchema extends AnySearchSchema = {},\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams> = AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams>,\n>(\n  options: Omit<\n    RouteOptions<\n      TRouteId,\n      TPath,\n      TParentSearchSchema,\n      TSearchSchema,\n      Expand<TParentSearchSchema & TSearchSchema>,\n      TParentParams,\n      TParams,\n      Expand<TParentParams & TAllParams>\n    >,\n    'path'\n  >,\n) => void\n\ntype CreateRouteConfigFn<\n  TIsRoot extends boolean = false,\n  TParentId extends string = string,\n  TParentPath extends string = string,\n  TParentRouteLoaderData extends AnyLoaderData = {},\n  TParentAllLoaderData extends AnyLoaderData = {},\n  TParentSearchSchema extends AnySearchSchema = {},\n  TParentParams extends AnyPathParams = {},\n> = <\n  TRouteId extends string,\n  TPath extends string,\n  TLoaderData extends AnyLoaderData,\n  TSearchSchema extends AnySearchSchema = AnySearchSchema,\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams> = AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams>,\n  TKnownChildren extends RouteConfig[] = RouteConfig[],\n  TResolvedId extends string = string extends TRouteId\n    ? string extends TPath\n      ? string\n      : TPath\n    : TRouteId,\n>(\n  options?: TIsRoot extends true\n    ? Omit<\n        RouteOptions<\n          TRouteId,\n          TPath,\n          TParentSearchSchema,\n          TSearchSchema,\n          Expand<TParentSearchSchema & TSearchSchema>,\n          TParentParams,\n          TParams,\n          Expand<TParentParams & TAllParams>\n        >,\n        'path'\n      > & { path?: never }\n    : RouteOptions<\n        TRouteId,\n        TPath,\n        TParentSearchSchema,\n        TSearchSchema,\n        Expand<TParentSearchSchema & TSearchSchema>,\n        TParentParams,\n        TParams,\n        Expand<TParentParams & TAllParams>\n      >,\n  children?: TKnownChildren,\n  isRoot?: boolean,\n  parentId?: string,\n  parentPath?: string,\n) => RouteConfig<\n  RoutePrefix<TParentId, TResolvedId>,\n  TResolvedId,\n  TPath,\n  string extends TPath ? '' : RoutePath<RoutePrefix<TParentPath, TPath>>,\n  TParentSearchSchema,\n  TSearchSchema,\n  Expand<TParentSearchSchema & TSearchSchema>,\n  TParentParams,\n  TParams,\n  Expand<TParentParams & TAllParams>,\n  TKnownChildren\n>\n\ntype RoutePath<T extends string> = T extends RootRouteId\n  ? '/'\n  : TrimPathRight<`${T}`>\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TId extends string,\n> = string extends TId\n  ? RootRouteId\n  : TId extends string\n  ? `${TPrefix}/${TId}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}`\n  : never\n\nexport interface AnyRouteConfig\n  extends RouteConfig<any, any, any, any, any, any, any, any, any, any, any> {}\n\nexport interface AnyRouteConfigWithChildren<TChildren>\n  extends RouteConfig<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    TChildren\n  > {}\n\ntype TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\ntype TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}`\n  ? TrimPathLeft<U>\n  : T extends `/${infer U}`\n  ? TrimPathLeft<U>\n  : T\ntype TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\nexport const createRouteConfig: CreateRouteConfigFn<true> = (\n  options = {} as any,\n  children = [] as any,\n  isRoot = true,\n  parentId,\n  parentPath,\n) => {\n  if (isRoot) {\n    ;(options as any).path = rootRouteId\n  }\n\n  // Strip the root from parentIds\n  if (parentId === rootRouteId) {\n    parentId = ''\n  }\n\n  let path: undefined | string = isRoot ? rootRouteId : options.path\n\n  // If the path is anything other than an index path, trim it up\n  if (path && path !== '/') {\n    path = trimPath(path)\n  }\n\n  const routeId = path || (options as { id?: string }).id\n\n  let id = joinPaths([parentId, routeId])\n\n  if (path === rootRouteId) {\n    path = '/'\n  }\n\n  if (id !== rootRouteId) {\n    id = joinPaths(['/', id])\n  }\n\n  const fullPath =\n    id === rootRouteId ? '/' : trimPathRight(joinPaths([parentPath, path]))\n\n  return {\n    id: id as any,\n    routeId: routeId as any,\n    path: path as any,\n    fullPath: fullPath as any,\n    options: options as any,\n    children,\n    addChildren: (children: any) =>\n      createRouteConfig(options, children, false, parentId, parentPath),\n    createRoute: (childOptions: any) =>\n      createRouteConfig(childOptions, undefined, false, id, fullPath) as any,\n    generate: () => {\n      invariant(\n        false,\n        `routeConfig.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `,\n      )\n    },\n  }\n}\n"],"names":["rootRouteId","createRouteConfig","options","children","isRoot","parentId","parentPath","path","trimPath","routeId","id","joinPaths","fullPath","trimPathRight","addChildren","createRoute","childOptions","undefined","generate","invariant"],"mappings":";;;;;;;;;;;;;;;;;;;;;AASO,MAAMA,WAAW,GAAG,WAAmB;AAsWvC,MAAMC,iBAA4C,GAAG,CAC1DC,OAAO,GAAG,EAAS,EACnBC,QAAQ,GAAG,EAAS,EACpBC,MAAM,GAAG,IAAI,EACbC,QAAQ,EACRC,UAAU,KACP;AACH,EAAA,IAAIF,MAAM,EAAE;IACRF,OAAO,CAASK,IAAI,GAAGP,WAAW,CAAA;AACtC,GAAA;;AAEA;EACA,IAAIK,QAAQ,KAAKL,WAAW,EAAE;AAC5BK,IAAAA,QAAQ,GAAG,EAAE,CAAA;AACf,GAAA;EAEA,IAAIE,MAAwB,GAAGH,MAAM,GAAGJ,WAAW,GAAGE,OAAO,CAACK,IAAI,CAAA;;AAElE;AACA,EAAA,IAAIA,MAAI,IAAIA,MAAI,KAAK,GAAG,EAAE;AACxBA,IAAAA,MAAI,GAAGC,aAAQ,CAACD,MAAI,CAAC,CAAA;AACvB,GAAA;AAEA,EAAA,MAAME,OAAO,GAAGF,MAAI,IAAKL,OAAO,CAAqBQ,EAAE,CAAA;EAEvD,IAAIA,EAAE,GAAGC,cAAS,CAAC,CAACN,QAAQ,EAAEI,OAAO,CAAC,CAAC,CAAA;EAEvC,IAAIF,MAAI,KAAKP,WAAW,EAAE;AACxBO,IAAAA,MAAI,GAAG,GAAG,CAAA;AACZ,GAAA;EAEA,IAAIG,EAAE,KAAKV,WAAW,EAAE;IACtBU,EAAE,GAAGC,cAAS,CAAC,CAAC,GAAG,EAAED,EAAE,CAAC,CAAC,CAAA;AAC3B,GAAA;AAEA,EAAA,MAAME,QAAQ,GACZF,EAAE,KAAKV,WAAW,GAAG,GAAG,GAAGa,kBAAa,CAACF,cAAS,CAAC,CAACL,UAAU,EAAEC,MAAI,CAAC,CAAC,CAAC,CAAA;EAEzE,OAAO;AACLG,IAAAA,EAAE,EAAEA,EAAS;AACbD,IAAAA,OAAO,EAAEA,OAAc;AACvBF,IAAAA,IAAI,EAAEA,MAAW;AACjBK,IAAAA,QAAQ,EAAEA,QAAe;AACzBV,IAAAA,OAAO,EAAEA,OAAc;IACvBC,QAAQ;AACRW,IAAAA,WAAW,EAAGX,QAAa,IACzBF,iBAAiB,CAACC,OAAO,EAAEC,QAAQ,EAAE,KAAK,EAAEE,QAAQ,EAAEC,UAAU,CAAC;AACnES,IAAAA,WAAW,EAAGC,YAAiB,IAC7Bf,iBAAiB,CAACe,YAAY,EAAEC,SAAS,EAAE,KAAK,EAAEP,EAAE,EAAEE,QAAQ,CAAQ;AACxEM,IAAAA,QAAQ,EAAE,MAAM;AACdC,MAAAA,6BAAS,CACP,KAAK,EACJ,CAAA,yIAAA,CAA0I,CAC5I,CAAA;AACH,KAAA;GACD,CAAA;AACH;;;;;"}